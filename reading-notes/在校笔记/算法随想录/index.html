<!DOCTYPE html>
<html lang="zh" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="算法题 代码随想录 一、数组 存放在连续内存空间上的相同类型数据的集合。\n1.二分查找 https://leetcode.cn/problems/binary-search/\n给定一个 n 个元素有序的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\nclass Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] &lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right] } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 时间复杂度：O(log n) 空间复杂度：O(1) 2.移除元素 https://leetcode.cn/problems/remove-element/\n">
<title>代码随想录 算法</title>

<link rel='canonical' href='https://pikapika-zrf.github.io/reading-notes/%E5%9C%A8%E6%A0%A1%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="代码随想录 算法">
<meta property='og:description' content="算法题 代码随想录 一、数组 存放在连续内存空间上的相同类型数据的集合。\n1.二分查找 https://leetcode.cn/problems/binary-search/\n给定一个 n 个元素有序的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\nclass Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] &lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right] } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 时间复杂度：O(log n) 空间复杂度：O(1) 2.移除元素 https://leetcode.cn/problems/remove-element/\n">
<meta property='og:url' content='https://pikapika-zrf.github.io/reading-notes/%E5%9C%A8%E6%A0%A1%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/'>
<meta property='og:site_name' content='raff Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Reading-Notes' /><meta property='article:published_time' content='2024-12-16T21:14:00&#43;08:00'/><meta property='article:modified_time' content='2024-12-16T21:14:00&#43;08:00'/>
<meta name="twitter:title" content="代码随想录 算法">
<meta name="twitter:description" content="算法题 代码随想录 一、数组 存放在连续内存空间上的相同类型数据的集合。\n1.二分查找 https://leetcode.cn/problems/binary-search/\n给定一个 n 个元素有序的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\nclass Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1] } else if (nums[middle] &lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right] } else { // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 } } // 未找到目标值 return -1; } }; 时间复杂度：O(log n) 空间复杂度：O(1) 2.移除元素 https://leetcode.cn/problems/remove-element/\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu5202140483351697843.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">raff Site</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/tech-blogs/' >
                
                
                
                <span>技术博客</span>
            </a>
        </li>
        
        
        <li >
            <a href='/reading-notes/' >
                
                
                
                <span>读书笔记</span>
            </a>
        </li>
        
        
        <li >
            <a href='/robot-notes/' >
                
                
                
                <span>机器人笔记</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/reading-notes/%E5%9C%A8%E6%A0%A1%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录 算法</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Dec 16, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    73 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="算法题">算法题
</h1><h1 id="代码随想录">代码随想录
</h1><h2 id="一数组">一、数组
</h2><p>存放在连续内存空间上的相同类型数据的集合。</p>
<h3 id="1二分查找">1.二分查找
</h3><p><a class="link" href="https://leetcode.cn/problems/binary-search/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/binary-search/</a></p>
<p>给定一个 n 个元素有序的整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> search(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 定义target在左闭右闭的区间里，[left, right]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;=</span> right) { <span style="color:#75715e">// 当left==right，区间[left, right]依然有效，所以用 &lt;=
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> middle <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> ((right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);<span style="color:#75715e">// 防止溢出 等同于(left + right)/2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (nums[middle] <span style="color:#f92672">&gt;</span> target) {
</span></span><span style="display:flex;"><span>                right <span style="color:#f92672">=</span> middle <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// target 在左区间，所以[left, middle - 1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (nums[middle] <span style="color:#f92672">&lt;</span> target) {
</span></span><span style="display:flex;"><span>                left <span style="color:#f92672">=</span> middle <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// target 在右区间，所以[middle + 1, right]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// nums[middle] == target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> middle; <span style="color:#75715e">// 数组中找到目标值，直接返回下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 未找到目标值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="2移除元素">2.移除元素
</h3><p><a class="link" href="https://leetcode.cn/problems/remove-element/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/remove-element/</a></p>
<p>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p><strong>双指针法</strong>。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> removeElement(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> slowIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> fastIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; fastIndex <span style="color:#f92672">&lt;</span> nums.size(); fastIndex<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (val <span style="color:#f92672">!=</span> nums[fastIndex]) {
</span></span><span style="display:flex;"><span>                nums[slowIndex<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> nums[fastIndex];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> slowIndex;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="3有序数组的平方">3.有序数组的平方
</h3><p><a class="link" href="https://leetcode.cn/problems/squares-of-a-sorted-array/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p><strong>双指针法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sortedSquares(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> A.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result(A.size(), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> A.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> j;) { <span style="color:#75715e">// 注意这里要i &lt;= j，因为最后要处理两个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (A[i] <span style="color:#f92672">*</span> A[i] <span style="color:#f92672">&lt;</span> A[j] <span style="color:#f92672">*</span> A[j])  {
</span></span><span style="display:flex;"><span>                result[k<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> A[j] <span style="color:#f92672">*</span> A[j];
</span></span><span style="display:flex;"><span>                j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                result[k<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> A[i] <span style="color:#f92672">*</span> A[i];
</span></span><span style="display:flex;"><span>                i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>时间复杂度为O(n)</p>
<h3 id="4长度最小的子数组">4.长度最小的子数组
</h3><p><a class="link" href="https://leetcode.cn/problems/minimum-size-subarray-sum/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p><strong>滑动窗口</strong>。就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minSubArrayLen(<span style="color:#66d9ef">int</span> s, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> INT32_MAX;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 滑动窗口数值之和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 滑动窗口起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> subLength <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 滑动窗口的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> nums.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> nums[j];
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (sum <span style="color:#f92672">&gt;=</span> s) {
</span></span><span style="display:flex;"><span>                subLength <span style="color:#f92672">=</span> (j <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 取子序列的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                result <span style="color:#f92672">=</span> result <span style="color:#f92672">&lt;</span> subLength <span style="color:#f92672">?</span> result : subLength;
</span></span><span style="display:flex;"><span>                sum <span style="color:#f92672">-=</span> nums[i<span style="color:#f92672">++</span>]; <span style="color:#75715e">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> result <span style="color:#f92672">==</span> INT32_MAX <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>一些录友会疑惑为什么时间复杂度是O(n)</strong>。</p>
<p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p>
<h2 id="二链表">二、链表
</h2><p>链表在内存中可不是连续分布的。通过指针域的指针链接在内存中各个节点。</p>
<p>链表的定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 单链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> val;  <span style="color:#75715e">// 节点上存储的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ListNode <span style="color:#f92672">*</span>next;  <span style="color:#75715e">// 指向下一个节点的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ListNode(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> val(x), next(NULL) {}  <span style="color:#75715e">// 节点的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>ListNode<span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(<span style="color:#ae81ff">5</span>); <span style="color:#75715e">//初始化节点
</span></span></span></code></pre></div><h3 id="1移除链表元素">1.移除链表元素
</h3><p><a class="link" href="https://leetcode.cn/problems/remove-linked-list-elements/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/remove-linked-list-elements/</a></p>
<p>题意：删除链表中等于给定值 val 的所有节点。</p>
<p><strong>设置一个虚拟头结点在进行移除节点操作：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> removeElements(ListNode<span style="color:#f92672">*</span> head, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> dummyHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 设置一个虚拟头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        dummyHead<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head; <span style="color:#75715e">// 将虚拟头结点指向head，这样方面后面做删除操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> dummyHead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> val) {
</span></span><span style="display:flex;"><span>                ListNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">delete</span> tmp;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        head <span style="color:#f92672">=</span> dummyHead<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> dummyHead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="2翻转链表">2.翻转链表
</h3><p><a class="link" href="https://leetcode.cn/problems/reverse-linked-list/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p><strong>双指针法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> reverseList(ListNode<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> temp; <span style="color:#75715e">// 保存cur的下一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(cur) {
</span></span><span style="display:flex;"><span>            temp <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;  <span style="color:#75715e">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pre; <span style="color:#75715e">// 翻转操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 更新pre 和 cur指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            pre <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pre;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="3两两交换链表中的节点">3.两两交换链表中的节点
</h3><p><a class="link" href="https://leetcode.cn/problems/swap-nodes-in-pairs/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png"
	
	
	
	loading="lazy"
	
		alt="24.两两交换链表中的节点1"
	
	
></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> swapPairs(ListNode<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> dummyHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 设置一个虚拟头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        dummyHead<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head; <span style="color:#75715e">// 将虚拟头结点指向head，这样方面后面做删除操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ListNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> dummyHead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>            ListNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">// 记录临时节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ListNode<span style="color:#f92672">*</span> tmp1 <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">// 记录临时节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;    <span style="color:#75715e">// 步骤一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> tmp;          <span style="color:#75715e">// 步骤二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> tmp1;   <span style="color:#75715e">// 步骤三
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">// cur移动两位，准备下一轮交换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dummyHead<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="4删除链表的倒数第n个节点">4.删除链表的倒数第N个节点
</h3><p><a class="link" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> removeNthFromEnd(ListNode<span style="color:#f92672">*</span> head, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> dummyHead <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        dummyHead<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> slow <span style="color:#f92672">=</span> dummyHead;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> dummyHead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n<span style="color:#f92672">--</span> <span style="color:#f92672">&amp;&amp;</span> fast <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        slow<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next; 
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// slow-&gt;next = tmp-&gt;next;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// delete nth;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dummyHead<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="5链表相交">5.链表相交
</h3><p><a class="link" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode <span style="color:#f92672">*</span>getIntersectionNode(ListNode <span style="color:#f92672">*</span>headA, ListNode <span style="color:#f92672">*</span>headB) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> curA <span style="color:#f92672">=</span> headA;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> curB <span style="color:#f92672">=</span> headB;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> lenA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, lenB <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (curA <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">// 求链表A的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            lenA<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            curA <span style="color:#f92672">=</span> curA<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (curB <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">// 求链表B的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            lenB<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            curB <span style="color:#f92672">=</span> curB<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        curA <span style="color:#f92672">=</span> headA;
</span></span><span style="display:flex;"><span>        curB <span style="color:#f92672">=</span> headB;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 让curA为最长链表的头，lenA为其长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (lenB <span style="color:#f92672">&gt;</span> lenA) {
</span></span><span style="display:flex;"><span>            swap (lenA, lenB);
</span></span><span style="display:flex;"><span>            swap (curA, curB);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 求长度差
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> gap <span style="color:#f92672">=</span> lenA <span style="color:#f92672">-</span> lenB;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 让curA和curB在同一起点上（末尾位置对齐）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (gap<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            curA <span style="color:#f92672">=</span> curA<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历curA 和 curB，遇到相同则直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (curA <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (curA <span style="color:#f92672">==</span> curB) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> curA;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            curA <span style="color:#f92672">=</span> curA<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            curB <span style="color:#f92672">=</span> curB<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n + m)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="6环形链表">6.环形链表
</h3><p><a class="link" href="https://leetcode.cn/problems/linked-list-cycle-ii/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png"
	
	
	
	loading="lazy"
	
		alt="img"
	
	
></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode <span style="color:#f92672">*</span>detectCycle(ListNode <span style="color:#f92672">*</span>head) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> slow <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(fast <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (slow <span style="color:#f92672">==</span> fast) {
</span></span><span style="display:flex;"><span>                ListNode<span style="color:#f92672">*</span> index1 <span style="color:#f92672">=</span> fast;
</span></span><span style="display:flex;"><span>                ListNode<span style="color:#f92672">*</span> index2 <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (index1 <span style="color:#f92672">!=</span> index2) {
</span></span><span style="display:flex;"><span>                    index1 <span style="color:#f92672">=</span> index1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                    index2 <span style="color:#f92672">=</span> index2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> index2; <span style="color:#75715e">// 返回环的入口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="三哈希表">三、哈希表
</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
<p>使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map（映射）</li>
</ul>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>集合</th>
          <th>底层实现</th>
          <th>是否有序</th>
          <th>数值是否可以重复</th>
          <th>能否更改数值</th>
          <th>查询效率</th>
          <th>增删效率</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>std::set</td>
          <td>红黑树</td>
          <td>有序</td>
          <td>否</td>
          <td>否</td>
          <td>O(log n)</td>
          <td>O(log n)</td>
      </tr>
      <tr>
          <td>std::multiset</td>
          <td>红黑树</td>
          <td>有序</td>
          <td>是</td>
          <td>否</td>
          <td>O(logn)</td>
          <td>O(logn)</td>
      </tr>
      <tr>
          <td>std::unordered_set</td>
          <td>哈希表</td>
          <td>无序</td>
          <td>否</td>
          <td>否</td>
          <td>O(1)</td>
          <td>O(1)</td>
      </tr>
  </tbody>
</table></div>
<p>std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>映射</th>
          <th>底层实现</th>
          <th>是否有序</th>
          <th>数值是否可以重复</th>
          <th>能否更改数值</th>
          <th>查询效率</th>
          <th>增删效率</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>std::map</td>
          <td>红黑树</td>
          <td>key有序</td>
          <td>key不可重复</td>
          <td>key不可修改</td>
          <td>O(logn)</td>
          <td>O(logn)</td>
      </tr>
      <tr>
          <td>std::multimap</td>
          <td>红黑树</td>
          <td>key有序</td>
          <td>key可重复</td>
          <td>key不可修改</td>
          <td>O(log n)</td>
          <td>O(log n)</td>
      </tr>
      <tr>
          <td>std::unordered_map</td>
          <td>哈希表</td>
          <td>key无序</td>
          <td>key不可重复</td>
          <td>key不可修改</td>
          <td>O(1)</td>
          <td>O(1)</td>
      </tr>
  </tbody>
</table></div>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<h3 id="1有效的字母异位词">1.有效的字母异位词
</h3><p><strong>用数组解决</strong></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isAnagram(string s, string t) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> record[<span style="color:#ae81ff">26</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            record[s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> t.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            record[t[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">26</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (record[i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// record数组所有元素都为零0，说明字符串s和t是字母异位词
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="2两个数组的交集">2.两个数组的交集
</h3><p><a class="link" href="https://leetcode.cn/problems/intersection-of-two-arrays/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/intersection-of-two-arrays/</a></p>
<p>题意：给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>使用unordered_set</strong></p>
<p>没有限制数值大小，无法使用数组来做哈希表。如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> intersection(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums1, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums2) {
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result_set; <span style="color:#75715e">// 存放结果，之所以用set是为了给结果集去重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums_set(nums1.begin(), nums1.end());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> num : nums2) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 发现nums2的元素 在nums_set里又出现过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (nums_set.find(num) <span style="color:#f92672">!=</span> nums_set.end()) {
</span></span><span style="display:flex;"><span>                result_set.insert(num);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(result_set.begin(), result_set.end());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(mn)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="3快乐数">3.快乐数
</h3><p><a class="link" href="https://leetcode.cn/problems/happy-number/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/happy-number/</a></p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>判断sum是否重复出现就可以使用unordered_set。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 取数值各个位上的单数之和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> getSum(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (n) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> (n <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">*</span> (n <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isHappy</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> set;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> getSum(n);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (set.find(sum) <span style="color:#f92672">!=</span> set.end()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                set.insert(sum);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> sum;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(logn)</li>
<li>空间复杂度: O(logn)</li>
</ul>
<h3 id="4两数之和">4.两数之和
</h3><p><a class="link" href="https://leetcode.cn/problems/two-sum/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/two-sum/</a></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p><strong>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</strong></p>
<p>我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p>数组中的元素作为key，value用来存下标。map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> twoSum(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>unordered_map <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> map;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 遍历当前元素，并在map中寻找是否有匹配的key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span> iter <span style="color:#f92672">=</span> map.find(target <span style="color:#f92672">-</span> nums[i]); 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(iter <span style="color:#f92672">!=</span> map.end()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> {iter<span style="color:#f92672">-&gt;</span>second, i};
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果没找到匹配对，就把访问过的元素和下标加入到map中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            map.insert(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(nums[i], i)); 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="5四数相加">5.四数相加Ⅱ
</h3><p><a class="link" href="https://leetcode.cn/problems/4sum-ii/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/4sum-ii/</a></p>
<ul>
<li>定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>
<li>统计A、B两个数组元素之和，和出现的次数，放到map中。</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fourSumCount(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> B, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> C, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> D) {
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> umap; <span style="color:#75715e">//key:a+b的数值，value:a+b数值出现的次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> a : A) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> b : B) {
</span></span><span style="display:flex;"><span>                umap[a <span style="color:#f92672">+</span> b]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 统计a+b+c+d = 0 出现的次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> c : C) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> d : D) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (umap.find(<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> (c <span style="color:#f92672">+</span> d)) <span style="color:#f92672">!=</span> umap.end()) {
</span></span><span style="display:flex;"><span>                    count <span style="color:#f92672">+=</span> umap[<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> (c <span style="color:#f92672">+</span> d)];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</li>
</ul>
<h3 id="6三数之和">6.三数之和
</h3><p><a class="link" href="https://leetcode.cn/problems/3sum/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/3sum/</a></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>哈希法。需要考虑较多情况。——》<strong>双指针法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>								
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> threeSum(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>        sort(nums.begin(), nums.end());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找出a + b + c = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// a = nums[i], b = nums[j], c = -(a + b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> nums[i] <span style="color:#f92672">==</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) { <span style="color:#75715e">//三元组元素a去重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> set;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> nums.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">&gt;</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;&amp;</span> nums[j] <span style="color:#f92672">==</span> nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;&amp;</span> nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]) { <span style="color:#75715e">// 三元组元素b去重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> (nums[i] <span style="color:#f92672">+</span> nums[j]);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (set.find(c) <span style="color:#f92672">!=</span> set.end()) {
</span></span><span style="display:flex;"><span>                    result.push_back({nums[i], nums[j], c});
</span></span><span style="display:flex;"><span>                    set.erase(c);<span style="color:#75715e">// 三元组元素c去重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    set.insert(nums[j]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n)，额外的 set 开销</li>
</ul>
<p><strong>双指针法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> threeSum(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>        sort(nums.begin(), nums.end());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找出a + b + c = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// a = nums[i], b = nums[left], c = nums[right]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 正确去重a方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> nums[i] <span style="color:#f92672">==</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">+</span> nums[left] <span style="color:#f92672">+</span> nums[right] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (nums[i] <span style="color:#f92672">+</span> nums[left] <span style="color:#f92672">+</span> nums[right] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    result.push_back(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>{nums[i], nums[left], nums[right]});
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&gt;</span> left <span style="color:#f92672">&amp;&amp;</span> nums[right] <span style="color:#f92672">==</span> nums[right <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&gt;</span> left <span style="color:#f92672">&amp;&amp;</span> nums[left] <span style="color:#f92672">==</span> nums[left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 找到答案时，双指针同时收缩
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                    left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="四字符串">四、字符串
</h2><h3 id="1反转字符串">1.反转字符串
</h3><p><a class="link" href="https://leetcode.cn/problems/reverse-string/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/reverse-string/</a></p>
<p>双指针法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> reverseString(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&amp;</span> s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> s.size()<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>; i<span style="color:#f92672">++</span>, j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            swap(s[i],s[j]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p><strong>反转字符串Ⅱ</strong></p>
<p><a class="link" href="https://leetcode.cn/problems/reverse-string-ii/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/reverse-string-ii/</a></p>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string reverseStr(string s, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i <span style="color:#f92672">+=</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> k)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 1. 每隔 2k 个字符的前 k 个字符进行反转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">+</span> k <span style="color:#f92672">&lt;=</span> s.size()) {
</span></span><span style="display:flex;"><span>                reverse(s.begin() <span style="color:#f92672">+</span> i, s.begin() <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> k );
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                reverse(s.begin() <span style="color:#f92672">+</span> i, s.end());
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="2替换空格">2.替换空格
</h3><p><strong><a class="link" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/ti-huan-kong-ge-lcof/</a></strong></p>
<p><strong>双指针法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string replaceSpace(string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 统计空格的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> sOldSize <span style="color:#f92672">=</span> s.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>) {
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 扩充字符串s的大小，也就是每个空格替换成&#34;%20&#34;之后的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        s.resize(s.size() <span style="color:#f92672">+</span> count <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sNewSize <span style="color:#f92672">=</span> s.size();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从后先前将空格替换为&#34;%20&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> sNewSize <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> sOldSize <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> i; i<span style="color:#f92672">--</span>, j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[j] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39; &#39;</span>) {
</span></span><span style="display:flex;"><span>                s[i] <span style="color:#f92672">=</span> s[j];
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>                s[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2&#39;</span>;
</span></span><span style="display:flex;"><span>                s[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;%&#39;</span>;
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="3翻转字符串里的单词">3.翻转字符串里的单词
</h3><p><a class="link" href="https://leetcode.cn/problems/reverse-words-in-a-string/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/reverse-words-in-a-string/</a></p>
<ul>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeExtraSpaces</span>(string <span style="color:#f92672">&amp;</span>s)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); <span style="color:#f92672">++</span>i) { <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39; &#39;</span>) { <span style="color:#75715e">//遇到非空格就处理，即删除所有空格。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (slow <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) s[slow<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39; &#39;</span>; <span style="color:#75715e">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> s.size() <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39; &#39;</span>) { <span style="color:#75715e">//补上该单词，遇到空格说明单词结束。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    s[slow<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> s[i<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        s.resize(slow); <span style="color:#75715e">//slow的大小即为去除多余空格后的大小。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    string <span style="color:#a6e22e">reverseWords</span>(string s) {
</span></span><span style="display:flex;"><span>        removeExtraSpaces(s); <span style="color:#75715e">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        reverse(s, <span style="color:#ae81ff">0</span>, s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//removeExtraSpaces后保证第一个单词的开始下标一定是0。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> s.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> s.size() <span style="color:#f92672">||</span> s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>) { <span style="color:#75715e">//到达空格或者串尾，说明一个单词结束。进行翻转。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                reverse(s, start, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">//翻转，注意是左闭右闭 []的翻转。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                start <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//更新下一个单词的开始下标start
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1) 或 O(n)，取决于语言中字符串是否可变</li>
</ul>
<h3 id="4左旋转字符串">4.左旋转字符串
</h3><p><a class="link" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a></p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string reverseLeftWords(string s, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        reverse(s.begin(), s.begin() <span style="color:#f92672">+</span> n);
</span></span><span style="display:flex;"><span>        reverse(s.begin() <span style="color:#f92672">+</span> n, s.end());
</span></span><span style="display:flex;"><span>        reverse(s.begin(), s.end());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="5实现-strstr">5.实现 strStr()
</h3><p><a class="link" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p>
<p>**KMP算法:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</p>
<p>KMP主要应用在<strong>字符串匹配</strong>上。</p>
<p><strong>next数组</strong>。前缀表统一减一，记录字符串有多大长度的相同前缀后缀 。j指向前缀末尾位置，i指向后缀末尾位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> getNext(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 注意i从1开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">!=</span> s[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) { <span style="color:#75715e">// 前后缀不相同了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                j <span style="color:#f92672">=</span> next[j]; <span style="color:#75715e">// 向前回退
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> s[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) { <span style="color:#75715e">// 找到相同的前后缀
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            next[i] <span style="color:#f92672">=</span> j; <span style="color:#75715e">// 将j（前缀的长度）赋给next[i]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">strStr</span>(string haystack, string needle) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (needle.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> next[needle.size()];
</span></span><span style="display:flex;"><span>        getNext(next, needle);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// // 因为next数组里记录的起始位置为-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> haystack.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 注意i就从0开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> haystack[i] <span style="color:#f92672">!=</span> needle[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) { <span style="color:#75715e">// 不匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                j <span style="color:#f92672">=</span> next[j]; <span style="color:#75715e">// j 寻找之前匹配的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (haystack[i] <span style="color:#f92672">==</span> needle[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) { <span style="color:#75715e">// 匹配，j和i同时向后移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                j<span style="color:#f92672">++</span>; <span style="color:#75715e">// i的增加在for循环里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> (needle.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) ) { <span style="color:#75715e">// 文本串s里出现了模式串t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> (i <span style="color:#f92672">-</span> needle.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n + m)</li>
<li>空间复杂度: O(m), 只需要保存字符串needle的前缀表</li>
</ul>
<h3 id="6重复的字符串">6.重复的字符串
</h3><p><a class="link" href="https://leetcode.cn/problems/repeated-substring-pattern/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/repeated-substring-pattern/</a></p>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p><strong>移动匹配</strong>。要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> repeatedSubstringPattern(string s) {
</span></span><span style="display:flex;"><span>        string t <span style="color:#f92672">=</span> s <span style="color:#f92672">+</span> s;
</span></span><span style="display:flex;"><span>        t.erase(t.begin()); t.erase(t.end() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 掐头去尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (t.find(s) <span style="color:#f92672">!=</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">::</span>npos) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// r
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p><strong>KMP</strong></p>
<p>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> getNext (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next, <span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>        next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">!=</span> s[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                j <span style="color:#f92672">=</span> next[j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(s[i] <span style="color:#f92672">==</span> s[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            next[i] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">repeatedSubstringPattern</span> (string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> next[s.size()];
</span></span><span style="display:flex;"><span>        getNext(next, s);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> s.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (next[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> len <span style="color:#f92672">%</span> (len <span style="color:#f92672">-</span> (next[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h2 id="五栈与队列">五、栈与队列
</h2><p>STL 栈 和队列被归类为容器适配器。栈的底层实现可以是vector，deque，list。<strong>默认是以deque</strong>。</p>
<p><strong>队列底层实现缺省情况下一样使用deque实现的。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> third;  <span style="color:#75715e">// 使用vector为底层容器的栈
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> third; 	<span style="color:#75715e">// 定义以list为底层容器的队列
</span></span></span></code></pre></div><h3 id="1用栈实现队列">1.用栈实现队列
</h3><p><a class="link" href="https://leetcode.cn/problems/implement-queue-using-stacks/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>
<p>用两个栈模拟队列，一个输入栈，一个输出栈。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyQueue</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stIn;
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stOut;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Initialize your data structure here. */</span>
</span></span><span style="display:flex;"><span>    MyQueue() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Push element x to the back of queue. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        stIn.push(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Removes the element from in front of queue and returns that element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (stOut.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 从stIn导入数据直到stIn为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stIn.empty()) {
</span></span><span style="display:flex;"><span>                stOut.push(stIn.top());
</span></span><span style="display:flex;"><span>                stIn.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> stOut.top();
</span></span><span style="display:flex;"><span>        stOut.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Get the front element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">peek</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>pop(); <span style="color:#75715e">// 直接使用已有的pop函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        stOut.push(res); <span style="color:#75715e">// 因为pop函数弹出了元素res，所以再添加回去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Returns whether the queue is empty. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stIn.empty() <span style="color:#f92672">&amp;&amp;</span> stOut.empty();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>
<p>时间复杂度: push和empty为O(1), pop和peek为O(n)</p>
</li>
<li>
<p>空间复杂度: O(n)</p>
</li>
</ul>
<h3 id="2用队列实现栈">2.用队列实现栈
</h3><p><a class="link" href="https://leetcode.cn/problems/implement-stack-using-queues/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/implement-stack-using-queues/</a></p>
<p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyStack</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> que;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Initialize your data structure here. */</span>
</span></span><span style="display:flex;"><span>    MyStack() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Push element x onto stack. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        que.push(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Removes the element on top of the stack and returns that element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> que.size();
</span></span><span style="display:flex;"><span>        size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (size<span style="color:#f92672">--</span>) { <span style="color:#75715e">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            que.push(que.front());
</span></span><span style="display:flex;"><span>            que.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> que.front(); <span style="color:#75715e">// 此时弹出的元素顺序就是栈的顺序了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        que.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Get the top element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">top</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> que.back();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Returns whether the stack is empty. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> que.empty();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: pop为O(n)，其他为O(1)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="3有效的括号">3.有效的括号
</h3><p><a class="link" href="https://leetcode.cn/problems/valid-parentheses/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/valid-parentheses/</a></p>
<p><strong>括号匹配是使用栈解决的经典问题。</strong></p>
<p>分析一下 这里有三种不匹配的情况</p>
<p>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。</p>
<p>第二种情况，括号没有多余，但是 括号的类型没有匹配上。</p>
<p>第三种情况，字符串里右方向的括号多余了，所以不匹配。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isValid(string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s.size() <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> false; <span style="color:#75715e">// 如果s的长度为奇数，一定不符合要求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> st;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) st.push(<span style="color:#e6db74">&#39;)&#39;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{&#39;</span>) st.push(<span style="color:#e6db74">&#39;}&#39;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;[&#39;</span>) st.push(<span style="color:#e6db74">&#39;]&#39;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (st.empty() <span style="color:#f92672">||</span> st.top() <span style="color:#f92672">!=</span> s[i]) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> st.pop(); <span style="color:#75715e">// st.top() 与 s[i]相等，栈弹出元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> st.empty();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="4删除字符串中的所有相邻重复项">4.删除字符串中的所有相邻重复项
</h3><p><a class="link" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a></p>
<p><strong>利用栈</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string removeDuplicates(string S) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> st;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">char</span> s : S) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (st.empty() <span style="color:#f92672">||</span> s <span style="color:#f92672">!=</span> st.top()) {
</span></span><span style="display:flex;"><span>                st.push(s);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                st.pop(); <span style="color:#75715e">// s 与 st.top()相等的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        string result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty()) { <span style="color:#75715e">// 将栈中元素放到result字符串汇总
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result <span style="color:#f92672">+=</span> st.top();
</span></span><span style="display:flex;"><span>            st.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        reverse (result.begin(), result.end()); <span style="color:#75715e">// 此时字符串需要反转一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<p><strong>拿字符串直接作为栈</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string removeDuplicates(string S) {
</span></span><span style="display:flex;"><span>        string result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">char</span> s : S) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(result.empty() <span style="color:#f92672">||</span> result.back() <span style="color:#f92672">!=</span> s) {
</span></span><span style="display:flex;"><span>                result.push_back(s);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                result.pop_back();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)，返回值不计空间复杂度</li>
</ul>
<h3 id="5逆波兰表达式后缀求值">5.逆波兰表达式（后缀）求值
</h3><p><a class="link" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p>
<p><strong>四则表达式（中缀）：9+（3-1）x3+10÷2</strong></p>
<p><strong>后缀表达式：9 3 1 - 3 x + 10 2 / +</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> evalRPN(vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> tokens) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 力扣修改了后台测试数据，需要用longlong
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> st; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> tokens.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">||</span> tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">||</span> tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">||</span> tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;/&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> num1 <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>                st.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> num2 <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>                st.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;+&#34;</span>) st.push(num2 <span style="color:#f92672">+</span> num1);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;-&#34;</span>) st.push(num2 <span style="color:#f92672">-</span> num1);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;*&#34;</span>) st.push(num2 <span style="color:#f92672">*</span> num1);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (tokens[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;/&#34;</span>) st.push(num2 <span style="color:#f92672">/</span> num1);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                st.push(stoll(tokens[i]));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>        st.pop(); <span style="color:#75715e">// 把栈里最后一个元素弹出（其实不弹出也没事）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="6滑动窗口最大值">6.滑动窗口最大值
</h3><p><a class="link" href="https://leetcode.cn/problems/sliding-window-maximum/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/sliding-window-maximum/</a></p>
<p>自定义一个队列。<strong>双端队列实现</strong>。队列单调递减。</p>
<p>pop弹出[i-k]的数。push时把之前小于val的数弹出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyQueue</span> { <span style="color:#75715e">//单调队列（从大到小）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> que; <span style="color:#75715e">// 使用deque来实现单调队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 同时pop之前判断队列当前是否为空。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop</span>(<span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>que.empty() <span style="color:#f92672">&amp;&amp;</span> value <span style="color:#f92672">==</span> que.front()) {
</span></span><span style="display:flex;"><span>                que.pop_front();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这样就保持了队列里的数值是单调从大到小的了。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>que.empty() <span style="color:#f92672">&amp;&amp;</span> value <span style="color:#f92672">&gt;</span> que.back()) {
</span></span><span style="display:flex;"><span>                que.pop_back();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            que.push_back(value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">front</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> que.front();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> maxSlidingWindow(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        MyQueue que;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 先将前k的元素放进队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            que.push(nums[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        result.push_back(que.front()); <span style="color:#75715e">// result 记录前k的元素的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> k; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            que.pop(nums[i <span style="color:#f92672">-</span> k]); <span style="color:#75715e">// 滑动窗口移除最前面元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            que.push(nums[i]); <span style="color:#75715e">// 滑动窗口前加入最后面的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result.push_back(que.front()); <span style="color:#75715e">// 记录对应的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(k)</li>
</ul>
<h3 id="7前k个高频元素">7.前k个高频元素
</h3><p><a class="link" href="https://leetcode.cn/problems/top-k-frequent-elements/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
<p>建<strong>小顶堆</strong>（优先级队列实现），维护前k个数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 小顶堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">mycomparison</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">const</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> lhs, <span style="color:#66d9ef">const</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> rhs) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> lhs.second <span style="color:#f92672">&gt;</span> rhs.second;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> topKFrequent(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 要统计元素出现频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> map; <span style="color:#75715e">// map&lt;nums[i],对应出现的次数&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            map[nums[i]]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对频率排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 定义一个小顶堆，大小为k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        priority_queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>, vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>, mycomparison<span style="color:#f92672">&gt;</span> pri_que;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 用固定大小为k的小顶堆，扫面所有频率的数值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> map.begin(); it <span style="color:#f92672">!=</span> map.end(); it<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            pri_que.push(<span style="color:#f92672">*</span>it);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pri_que.size() <span style="color:#f92672">&gt;</span> k) { <span style="color:#75715e">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                pri_que.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result(k);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            result[i] <span style="color:#f92672">=</span> pri_que.top().first;
</span></span><span style="display:flex;"><span>            pri_que.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(nlogk)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h2 id="六二叉树">六、二叉树
</h2><p><strong>满二叉树</strong>。深度为k，有2^k-1个节点</p>
<!-- raw HTML omitted -->
<p><strong>完全二叉树</strong>。在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p>
<!-- raw HTML omitted -->
<p><strong>二叉搜索树</strong>。左子树节点值小于根节点。右子树节点值大于根节点。</p>
<p><strong>平衡二叉搜索树</strong>。又被称为AVL（Adelson-Velsky and Landis）树。左右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉搜索树。</p>
<p><strong>存储方式</strong>：</p>
<p><strong>链式存储</strong>。指针</p>
<p><strong>顺序存储</strong>。数组</p>
<!-- raw HTML omitted -->
<p>父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</p>
<p>二叉树主要有两种<strong>遍历方式</strong>：</p>
<ol>
<li><strong>深度优先遍历</strong>：先往深走，遇到叶子节点再往回走。
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li><strong>广度优先遍历</strong>：一层一层的去遍历。
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ol>
<p><strong>定义（链式存储）：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> val(x), left(NULL), right(NULL) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="递归">递归
</h3><p><strong>前序遍历为例：</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> traversal(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> vec)
</span></span></code></pre></div><ol start="2">
<li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span></code></pre></div><ol start="3">
<li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vec.push_back(cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>traversal(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>traversal(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span></code></pre></div><p>单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：</p>
<h3 id="1递归遍历">1.递归遍历
</h3><p><strong>前序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> traversal(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> vec) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        vec.push_back(cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        traversal(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        traversal(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        traversal(root, result);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>中序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> vec) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    traversal(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec.push_back(cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    traversal(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>后序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> vec) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    traversal(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    traversal(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec.push_back(cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="2迭代遍历">2.迭代遍历
</h3><p><strong>前序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> st;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>        st.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> st.top();                       <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            st.pop();
</span></span><span style="display:flex;"><span>            result.push_back(node<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) st.push(node<span style="color:#f92672">-&gt;</span>right);           <span style="color:#75715e">// 右（空节点不入栈）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) st.push(node<span style="color:#f92672">-&gt;</span>left);             <span style="color:#75715e">// 左（空节点不入栈）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>中序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> inorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> st;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">// 指针来访问节点，访问到最底层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(cur); <span style="color:#75715e">// 将访问的节点放进栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>left;                <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                cur <span style="color:#f92672">=</span> st.top(); <span style="color:#75715e">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.pop();
</span></span><span style="display:flex;"><span>                result.push_back(cur<span style="color:#f92672">-&gt;</span>val);     <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>right;               <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>后序遍历</strong></p>
<p>由先序遍历翻转：中左右-》中右左-》左右中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> postorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> st;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>        st.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>            st.pop();
</span></span><span style="display:flex;"><span>            result.push_back(node<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) st.push(node<span style="color:#f92672">-&gt;</span>left); <span style="color:#75715e">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) st.push(node<span style="color:#f92672">-&gt;</span>right); <span style="color:#75715e">// 空节点不入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        reverse(result.begin(), result.end()); <span style="color:#75715e">// 将结果反转之后就是左右中的顺序了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>统一的迭代法</strong></p>
<p><strong>要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong></p>
<p><strong>迭代法中序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> inorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> st;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">!=</span> NULL) st.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                st.pop(); <span style="color:#75715e">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) st.push(node<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 添加右节点（空节点不入栈）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>                st.push(node);                          <span style="color:#75715e">// 添加中节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(NULL); <span style="color:#75715e">// 中节点访问过，但是还没有处理，加入空节点做为标记。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) st.push(node<span style="color:#f92672">-&gt;</span>left);    <span style="color:#75715e">// 添加左节点（空节点不入栈）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 只有遇到空节点的时候，才将下一个节点放进结果集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.pop();           <span style="color:#75715e">// 将空节点弹出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                node <span style="color:#f92672">=</span> st.top();    <span style="color:#75715e">// 重新取出栈中元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.pop();
</span></span><span style="display:flex;"><span>                result.push_back(node<span style="color:#f92672">-&gt;</span>val); <span style="color:#75715e">// 加入到结果集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="3层序遍历">3.层序遍历
</h3><p><a class="link" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
<p><strong>使用队列实现</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> levelOrder(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> que;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">!=</span> NULL) que.push(root);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>que.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> que.size();
</span></span><span style="display:flex;"><span>            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> que.front();
</span></span><span style="display:flex;"><span>                que.pop();
</span></span><span style="display:flex;"><span>                vec.push_back(node<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) que.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) que.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            result.push_back(vec);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="4翻转二叉树">4.翻转二叉树
</h3><p><a class="link" href="https://leetcode.cn/problems/invert-binary-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/invert-binary-tree/</a></p>
<p><strong>把每一个节点的左右孩子翻转</strong></p>
<p>递归</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> invertTree(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        swap(root<span style="color:#f92672">-&gt;</span>left, root<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        invertTree(root<span style="color:#f92672">-&gt;</span>left);         <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        invertTree(root<span style="color:#f92672">-&gt;</span>right);        <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>前序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> invertTree(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> st;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">!=</span> NULL) st.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                st.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) st.push(node<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) st.push(node<span style="color:#f92672">-&gt;</span>left);    <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(node);                          <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(NULL);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                st.pop();
</span></span><span style="display:flex;"><span>                node <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>                st.pop();
</span></span><span style="display:flex;"><span>                swap(node<span style="color:#f92672">-&gt;</span>left, node<span style="color:#f92672">-&gt;</span>right);          <span style="color:#75715e">// 节点处理逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>层序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> invertTree(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> que;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">!=</span> NULL) que.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>que.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> que.size();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> que.front();
</span></span><span style="display:flex;"><span>                que.pop();
</span></span><span style="display:flex;"><span>                swap(node<span style="color:#f92672">-&gt;</span>left, node<span style="color:#f92672">-&gt;</span>right); <span style="color:#75715e">// 节点处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) que.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) que.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="5对称二叉树">5.对称二叉树
</h3><p><a class="link" href="https://leetcode.cn/problems/symmetric-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/symmetric-tree/</a></p>
<p>只能用<strong>后序遍历</strong>，左右子树判断对称，再判断中间节点</p>
<p>左子树的左子树==右子数的右子树；左子树的右子树==右子树的左子树。</p>
<p>递归</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> compare(TreeNode<span style="color:#f92672">*</span> left, TreeNode<span style="color:#f92672">*</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 首先排除空节点的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">!=</span> NULL) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (left <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 排除了空节点，再排除数值不相同的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (left<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">!=</span> right<span style="color:#f92672">-&gt;</span>val) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 此时就是：左右节点都不为空，且数值相同的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 此时才做递归，做下一层的判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">bool</span> outside <span style="color:#f92672">=</span> compare(left<span style="color:#f92672">-&gt;</span>left, right<span style="color:#f92672">-&gt;</span>right);   <span style="color:#75715e">// 左子树：左、 右子树：右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">bool</span> inside <span style="color:#f92672">=</span> compare(left<span style="color:#f92672">-&gt;</span>right, right<span style="color:#f92672">-&gt;</span>left);    <span style="color:#75715e">// 左子树：右、 右子树：左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">bool</span> isSame <span style="color:#f92672">=</span> outside <span style="color:#f92672">&amp;&amp;</span> inside;                    <span style="color:#75715e">// 左子树：中、 右子树：中 （逻辑处理）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> isSame;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSymmetric</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> compare(root<span style="color:#f92672">-&gt;</span>left, root<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>使用队列（栈也可以）</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isSymmetric(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> que;
</span></span><span style="display:flex;"><span>        que.push(root<span style="color:#f92672">-&gt;</span>left);   <span style="color:#75715e">// 将左子树头结点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        que.push(root<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 将右子树头结点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>que.empty()) {  <span style="color:#75715e">// 接下来就要判断这两个树是否相互翻转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            TreeNode<span style="color:#f92672">*</span> leftNode <span style="color:#f92672">=</span> que.front(); que.pop();
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> rightNode <span style="color:#f92672">=</span> que.front(); que.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>leftNode <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>rightNode) {  <span style="color:#75715e">// 左节点为空、右节点为空，此时说明是对称的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 左右一个节点不为空，或者都不为空但数值不相同，返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">!</span>leftNode <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>rightNode <span style="color:#f92672">||</span> (leftNode<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">!=</span> rightNode<span style="color:#f92672">-&gt;</span>val))) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            que.push(leftNode<span style="color:#f92672">-&gt;</span>left);   <span style="color:#75715e">// 加入左节点左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            que.push(rightNode<span style="color:#f92672">-&gt;</span>right); <span style="color:#75715e">// 加入右节点右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            que.push(leftNode<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 加入左节点右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            que.push(rightNode<span style="color:#f92672">-&gt;</span>left);  <span style="color:#75715e">// 加入右节点左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="6二叉树的最大深度">6.二叉树的最大深度
</h3><p><a class="link" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p>
<p>递归。取左右子树的最大值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> getdepth(TreeNode<span style="color:#f92672">*</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftdepth <span style="color:#f92672">=</span> getdepth(node<span style="color:#f92672">-&gt;</span>left);       <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> rightdepth <span style="color:#f92672">=</span> getdepth(node<span style="color:#f92672">-&gt;</span>right);     <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> depth <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max(leftdepth, rightdepth); <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> depth;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getdepth(root);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>层序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxDepth(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> depth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> que;
</span></span><span style="display:flex;"><span>        que.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>que.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> que.size();
</span></span><span style="display:flex;"><span>            depth<span style="color:#f92672">++</span>; <span style="color:#75715e">// 记录深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> que.front();
</span></span><span style="display:flex;"><span>                que.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) que.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) que.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> depth;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="7二叉树的最小深度">7.二叉树的最小深度
</h3><p><a class="link" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p>
<p><strong>后序</strong>。必须从树叶节点算最小深度</p>
<p>左子树为空，右子树不为空，最小深度： 1 + 右子树的深度。</p>
<p>右子树为空，左子树不为空，最小深度： 1 + 左子树的深度。</p>
<p>左右子树都不为空，最小深度：左右子树深度最小值 + 1 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> getDepth(TreeNode<span style="color:#f92672">*</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftDepth <span style="color:#f92672">=</span> getDepth(node<span style="color:#f92672">-&gt;</span>left);           <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> rightDepth <span style="color:#f92672">=</span> getDepth(node<span style="color:#f92672">-&gt;</span>right);         <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                                        <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 当一个左子树为空，右不为空，这时并不是最低点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> NULL) { 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> rightDepth;
</span></span><span style="display:flex;"><span>        }   
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 当一个右子树为空，左不为空，这时并不是最低点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL) { 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> leftDepth;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> min(leftDepth, rightDepth);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minDepth</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getDepth(root);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>层序遍历</strong></p>
<p><strong>只有当左右孩子都为空的时候，才说明遍历到最低点了。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minDepth(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> depth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> que;
</span></span><span style="display:flex;"><span>        que.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>que.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> que.size();
</span></span><span style="display:flex;"><span>            depth<span style="color:#f92672">++</span>; <span style="color:#75715e">// 记录最小深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> que.front();
</span></span><span style="display:flex;"><span>                que.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) que.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) que.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>node<span style="color:#f92672">-&gt;</span>right) { <span style="color:#75715e">// 当左右孩子都为空的时候，说明是最低点的一层了，退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">return</span> depth;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> depth;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="8完全二叉树的节点个数">8.完全二叉树的节点个数
</h3><p><a class="link" href="https://leetcode.cn/problems/count-complete-tree-nodes/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> getNodesNum(TreeNode<span style="color:#f92672">*</span> cur) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftNum <span style="color:#f92672">=</span> getNodesNum(cur<span style="color:#f92672">-&gt;</span>left);      <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> rightNum <span style="color:#f92672">=</span> getNodesNum(cur<span style="color:#f92672">-&gt;</span>right);    <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> treeNum <span style="color:#f92672">=</span> leftNum <span style="color:#f92672">+</span> rightNum <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;      <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> treeNum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> countNodes(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">getNodesNum</span>(root);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>层序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> countNodes(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> que;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">!=</span> NULL) que.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>que.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> que.size();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> que.front();
</span></span><span style="display:flex;"><span>                que.pop();
</span></span><span style="display:flex;"><span>                result<span style="color:#f92672">++</span>;   <span style="color:#75715e">// 记录节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) que.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) que.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="9平衡二叉树">9.平衡二叉树
</h3><p><a class="link" href="https://leetcode.cn/problems/balanced-binary-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p><strong>左右子树高度差大与1就返回-1。</strong></p>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> getHeight(TreeNode<span style="color:#f92672">*</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftHeight <span style="color:#f92672">=</span> getHeight(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (leftHeight <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rightHeight <span style="color:#f92672">=</span> getHeight(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rightHeight <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">abs</span>(leftHeight <span style="color:#f92672">-</span> rightHeight) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max(leftHeight, rightHeight);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isBalanced</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getHeight(root) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> false <span style="color:#f92672">:</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="10二叉树的所有路径">10.二叉树的所有路径
</h3><p><a class="link" href="https://leetcode.cn/problems/binary-tree-paths/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/binary-tree-paths/description/</a></p>
<p><strong>回溯</strong></p>
<p>递归函数后弹出前一个结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> traversal(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> path, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> result) {
</span></span><span style="display:flex;"><span>        path.push_back(cur<span style="color:#f92672">-&gt;</span>val); <span style="color:#75715e">// 中，中为什么写在这里，因为最后一个节点也要加入到path中 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这才到了叶子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> cur<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            string sPath;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> path.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                sPath <span style="color:#f92672">+=</span> to_string(path[i]);
</span></span><span style="display:flex;"><span>                sPath <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;-&gt;&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            sPath <span style="color:#f92672">+=</span> to_string(path[path.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            result.push_back(sPath);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>left) { <span style="color:#75715e">// 左 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            traversal(cur<span style="color:#f92672">-&gt;</span>left, path, result);
</span></span><span style="display:flex;"><span>            path.pop_back(); <span style="color:#75715e">// 回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>right) { <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            traversal(cur<span style="color:#f92672">-&gt;</span>right, path, result);
</span></span><span style="display:flex;"><span>            path.pop_back(); <span style="color:#75715e">// 回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> binaryTreePaths(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>        traversal(root, path, result);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="11左叶子之和">11.左叶子之和
</h3><p><a class="link" href="https://leetcode.cn/problems/sum-of-left-leaves/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/sum-of-left-leaves/description/</a></p>
<p>判断是不是左叶子：该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空</p>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sumOfLeftLeaves(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftValue <span style="color:#f92672">=</span> sumOfLeftLeaves(root<span style="color:#f92672">-&gt;</span>left);    <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right) { <span style="color:#75715e">// 左子树就是一个左叶子的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            leftValue <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rightValue <span style="color:#f92672">=</span> sumOfLeftLeaves(root<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> leftValue <span style="color:#f92672">+</span> rightValue;               <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>迭代</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sumOfLeftLeaves(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> st;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        st.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>            st.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                result <span style="color:#f92672">+=</span> node<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) st.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) st.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="12从中序与后序遍历序列构造二叉树">12.从中序与后序遍历序列构造二叉树
</h3><p><a class="link" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p>
<p>以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> traversal (vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> inorder, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> postorder) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (postorder.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 后序遍历数组最后一个元素，就是当前的中间节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> rootValue <span style="color:#f92672">=</span> postorder[postorder.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(rootValue);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 叶子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (postorder.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找到中序遍历的切割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> delimiterIndex;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (delimiterIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; delimiterIndex <span style="color:#f92672">&lt;</span> inorder.size(); delimiterIndex<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (inorder[delimiterIndex] <span style="color:#f92672">==</span> rootValue) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 切割中序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 左闭右开区间：[0, delimiterIndex)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> leftInorder(inorder.begin(), inorder.begin() <span style="color:#f92672">+</span> delimiterIndex);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// [delimiterIndex + 1, end)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> rightInorder(inorder.begin() <span style="color:#f92672">+</span> delimiterIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, inorder.end() );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// postorder 舍弃末尾元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        postorder.resize(postorder.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 切割后序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// [0, leftInorder.size)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> leftPostorder(postorder.begin(), postorder.begin() <span style="color:#f92672">+</span> leftInorder.size());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// [leftInorder.size(), end)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> rightPostorder(postorder.begin() <span style="color:#f92672">+</span> leftInorder.size(), postorder.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> traversal(leftInorder, leftPostorder);
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> traversal(rightInorder, rightPostorder);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> buildTree(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> inorder, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> postorder) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (inorder.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> postorder.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">traversal</span>(inorder, postorder);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="13最大二叉树">13.最大二叉树
</h3><p><a class="link" href="https://leetcode.cn/problems/maximum-binary-tree/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/maximum-binary-tree/description/</a></p>
<p>前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在左闭右开区间[left, right)，构造二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    TreeNode<span style="color:#f92672">*</span> traversal(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">&gt;=</span> right) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 分割点下标：maxValueIndex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> maxValueIndex <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> right; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&gt;</span> nums[maxValueIndex]) maxValueIndex <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(nums[maxValueIndex]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 左闭右开：[left, maxValueIndex)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> traversal(nums, left, maxValueIndex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 左闭右开：[maxValueIndex + 1, right)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> traversal(nums, maxValueIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> constructMaximumBinaryTree(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">traversal</span>(nums, <span style="color:#ae81ff">0</span>, nums.size());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="14合并二叉树">14.合并二叉树
</h3><p><a class="link" href="https://leetcode.cn/problems/merge-two-binary-trees/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/merge-two-binary-trees/description/</a></p>
<p><strong>前序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> mergeTrees(TreeNode<span style="color:#f92672">*</span> t1, TreeNode<span style="color:#f92672">*</span> t2) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t1 <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> t2; <span style="color:#75715e">// 如果t1为空，合并之后就应该是t2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (t2 <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> t1; <span style="color:#75715e">// 如果t2为空，合并之后就应该是t1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 修改了t1的数值和结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        t1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">+=</span> t2<span style="color:#f92672">-&gt;</span>val;                             <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        t1<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> mergeTrees(t1<span style="color:#f92672">-&gt;</span>left, t2<span style="color:#f92672">-&gt;</span>left);      <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        t1<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> mergeTrees(t1<span style="color:#f92672">-&gt;</span>right, t2<span style="color:#f92672">-&gt;</span>right);   <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> t1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>重新定义树</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> mergeTrees(TreeNode<span style="color:#f92672">*</span> t1, TreeNode<span style="color:#f92672">*</span> t2) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t1 <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> t2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t2 <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> t1;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 重新定义新的节点，不修改原有两个树的结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">=</span> t1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">+</span> t2<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> mergeTrees(t1<span style="color:#f92672">-&gt;</span>left, t2<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> mergeTrees(t1<span style="color:#f92672">-&gt;</span>right, t2<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>层序遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> mergeTrees(TreeNode<span style="color:#f92672">*</span> t1, TreeNode<span style="color:#f92672">*</span> t2) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t1 <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> t2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t2 <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> t1;
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> que;
</span></span><span style="display:flex;"><span>        que.push(t1);
</span></span><span style="display:flex;"><span>        que.push(t2);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>que.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node1 <span style="color:#f92672">=</span> que.front(); que.pop();
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node2 <span style="color:#f92672">=</span> que.front(); que.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 此时两个节点一定不为空，val相加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            node1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">+=</span> node2<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果两棵树左节点都不为空，加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (node1<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> node2<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                que.push(node1<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                que.push(node2<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果两棵树右节点都不为空，加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (node1<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> node2<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                que.push(node1<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>                que.push(node2<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 当t1的左节点 为空 t2左节点不为空，就赋值过去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (node1<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> node2<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                node1<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node2<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 当t1的右节点 为空 t2右节点不为空，就赋值过去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (node1<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> node2<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                node1<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node2<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> t1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="15二叉搜索树中的搜索">15.二叉搜索树中的搜索
</h3><p><a class="link" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/search-in-a-binary-search-tree/description/</a></p>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> searchBST(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> val) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> result <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> val) result <span style="color:#f92672">=</span> searchBST(root<span style="color:#f92672">-&gt;</span>left, val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> val) result <span style="color:#f92672">=</span> searchBST(root<span style="color:#f92672">-&gt;</span>right, val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>迭代</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> searchBST(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (root <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> val) root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> val) root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="16验证二叉搜索数">16.验证二叉搜索数
</h3><p><a class="link" href="https://leetcode.cn/problems/validate-binary-search-tree/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/validate-binary-search-tree/description/</a></p>
<p>二叉树转成数组，再判断。二叉搜索树采用中序遍历，就是一个有序数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        traversal(root<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        vec.push_back(root<span style="color:#f92672">-&gt;</span>val); <span style="color:#75715e">// 将二叉搜索树转换为有序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        traversal(root<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isValidBST(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vec.clear(); <span style="color:#75715e">// 不加这句在leetcode上也可以过，但最好加上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        traversal(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> vec.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 注意要小于等于，搜索树里不能有相同元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (vec[i] <span style="color:#f92672">&lt;=</span> vec[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="17二叉搜索树中的众数">17.二叉搜索树中的众数
</h3><p>方法一。转成数组，用哈希算</p>
<p>方法二。<strong>遍历</strong>时算</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 最大频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 统计频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    TreeNode<span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">searchBST</span>(TreeNode<span style="color:#f92672">*</span> cur) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        searchBST(cur<span style="color:#f92672">-&gt;</span>left);       <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pre <span style="color:#f92672">==</span> NULL) { <span style="color:#75715e">// 第一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (pre<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> cur<span style="color:#f92672">-&gt;</span>val) { <span style="color:#75715e">// 与前一个节点数值相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 与前一个节点数值不同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> cur; <span style="color:#75715e">// 更新上一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> maxCount) { <span style="color:#75715e">// 如果和最大值相同，放进result中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result.push_back(cur<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&gt;</span> maxCount) { <span style="color:#75715e">// 如果计数大于最大值频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            maxCount <span style="color:#f92672">=</span> count;   <span style="color:#75715e">// 更新最大频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result.clear();     <span style="color:#75715e">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result.push_back(cur<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        searchBST(cur<span style="color:#f92672">-&gt;</span>right);      <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> findMode(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> pre <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">// 记录前一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        result.clear();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        searchBST(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="18二叉树的最近公共祖先">18.二叉树的最近公共祖先
</h3><p><a class="link" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p><strong>递归回溯</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> lowestCommonAncestor(TreeNode<span style="color:#f92672">*</span> root, TreeNode<span style="color:#f92672">*</span> p, TreeNode<span style="color:#f92672">*</span> q) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> q <span style="color:#f92672">||</span> root <span style="color:#f92672">==</span> p <span style="color:#f92672">||</span> root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> left <span style="color:#f92672">=</span> lowestCommonAncestor(root<span style="color:#f92672">-&gt;</span>left, p, q);
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> right <span style="color:#f92672">=</span> lowestCommonAncestor(root<span style="color:#f92672">-&gt;</span>right, p, q);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">!=</span> NULL) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">!=</span> NULL) <span style="color:#66d9ef">return</span> right;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (left <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> left;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>  { <span style="color:#75715e">//  (left == NULL &amp;&amp; right == NULL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="19二叉搜索树的插入操作">19.二叉搜索树的插入操作
</h3><p><a class="link" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/insert-into-a-binary-search-tree/</a></p>
<p>数值插入后仍为二叉搜索数</p>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> insertIntoBST(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(val);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> val) root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> insertIntoBST(root<span style="color:#f92672">-&gt;</span>left, val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> val) root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> insertIntoBST(root<span style="color:#f92672">-&gt;</span>right, val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>迭代</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> insertIntoBST(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(val);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> parent <span style="color:#f92672">=</span> root; <span style="color:#75715e">// 这个很重要，需要记录上一个节点，否则无法赋值新节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            parent <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> val) cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (val <span style="color:#f92672">&lt;</span> parent<span style="color:#f92672">-&gt;</span>val) parent<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node;<span style="color:#75715e">// 此时是用parent节点的进行赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> parent<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="20删除二叉搜索树中的节点">20.删除二叉搜索树中的节点
</h3><p><a class="link" href="https://leetcode.cn/problems/delete-node-in-a-bst/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/delete-node-in-a-bst/description/</a></p>
<p>五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点
<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> deleteNode(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> root; <span style="color:#75715e">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">///! 内存释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">delete</span> root;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> retNode <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">///! 内存释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">delete</span> root;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> retNode;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> retNode <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">///! 内存释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">delete</span> root;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> retNode;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 并返回删除节点右孩子为新的根节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                TreeNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right; <span style="color:#75715e">// 找右子树最左面的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">while</span>(cur<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                    cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                cur<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>left; <span style="color:#75715e">// 把要删除的节点（root）左子树放在cur的左孩子的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                TreeNode<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> root;   <span style="color:#75715e">// 把root节点保存一下，下面来删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                root <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right;     <span style="color:#75715e">// 返回旧root的右孩子作为新root
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">delete</span> tmp;             <span style="color:#75715e">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> key) root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> deleteNode(root<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> key) root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> deleteNode(root<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>普通二叉树的删除</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> deleteNode(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) { <span style="color:#75715e">// 这里第二次操作目标值：最终删除的作用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> root<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            TreeNode <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (cur<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>                cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            swap(root<span style="color:#f92672">-&gt;</span>val, cur<span style="color:#f92672">-&gt;</span>val); <span style="color:#75715e">// 这里第一次操作目标值：交换目标值其右子树最左面节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> deleteNode(root<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> deleteNode(root<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="21修剪二叉搜索树">21.修剪二叉搜索树
</h3><p><a class="link" href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/trim-a-binary-search-tree/description/</a></p>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> trimBST(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span> ) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> low) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> right <span style="color:#f92672">=</span> trimBST(root<span style="color:#f92672">-&gt;</span>right, low, high); <span style="color:#75715e">// 寻找符合区间[low, high]的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> high) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> left <span style="color:#f92672">=</span> trimBST(root<span style="color:#f92672">-&gt;</span>left, low, high); <span style="color:#75715e">// 寻找符合区间[low, high]的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> left;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> trimBST(root<span style="color:#f92672">-&gt;</span>left, low, high); <span style="color:#75715e">// root-&gt;left接入符合条件的左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> trimBST(root<span style="color:#f92672">-&gt;</span>right, low, high); <span style="color:#75715e">// root-&gt;right接入符合条件的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="22有序数组转换成二叉搜索树">22.有序数组转换成二叉搜索树
</h3><p><a class="link" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/</a></p>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> traversal(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">&gt;</span> right) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> ((right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(nums[mid]);
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> traversal(nums, left, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> traversal(nums, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, right);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> sortedArrayToBST(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> traversal(nums, <span style="color:#ae81ff">0</span>, nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="23把二叉搜索树转换成累加树">23.把二叉搜索树转换成累加树
</h3><p><a class="link" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/convert-bst-to-greater-tree/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pre <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 记录前一个节点的数值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> cur) { <span style="color:#75715e">// 右中左遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        traversal(cur<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        cur<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">+=</span> pre;
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        traversal(cur<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> convertBST(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        traversal(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="七回溯算法">七、回溯算法
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>void backtracking(参数) {
</span></span><span style="display:flex;"><span>    if (终止条件) {
</span></span><span style="display:flex;"><span>        存放结果;
</span></span><span style="display:flex;"><span>        return;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
</span></span><span style="display:flex;"><span>        处理节点;
</span></span><span style="display:flex;"><span>        backtracking(路径，选择列表); // 递归
</span></span><span style="display:flex;"><span>        回溯，撤销处理结果
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="1组合问题">1.组合问题
</h3><p><a class="link" href="https://leetcode.cn/problems/combinations/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/combinations/description/</a></p>
<p>for循环用来横向遍历，递归是纵向遍历。时间复杂度: O(n * 2^n)。空间复杂度: O(n)</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result; <span style="color:#75715e">// 存放符合条件结果的集合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path; <span style="color:#75715e">// 用来存放符合条件结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> startIndex) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (path.size() <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            path.push_back(i); <span style="color:#75715e">// 处理节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            backtracking(n, k, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            path.pop_back(); <span style="color:#75715e">// 回溯，撤销处理的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> combine(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        result.clear(); <span style="color:#75715e">// 可以不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        path.clear();   <span style="color:#75715e">// 可以不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        backtracking(n, k, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<p><strong>优化</strong></p>
<p>原因：<strong>for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了</strong></p>
<p>for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) {</p>
<ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="2组合总和">2.组合总和Ⅲ
</h3><p><a class="link" href="https://leetcode.cn/problems/combination-sum-iii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/combination-sum-iii/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result; <span style="color:#75715e">// 存放结果集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path; <span style="color:#75715e">// 符合条件的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// targetSum：目标和，也就是题目中的n。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// k：题目中要求k个数的集合。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// sum：已经收集的元素的总和，也就是path里元素的总和。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// startIndex：下一层for循环搜索的起始位置。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(<span style="color:#66d9ef">int</span> targetSum, <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> sum, <span style="color:#66d9ef">int</span> startIndex) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (path.size() <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">==</span> targetSum) result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// 如果path.size() == k 但sum != targetSum 直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> i; <span style="color:#75715e">// 处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            path.push_back(i); <span style="color:#75715e">// 处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            backtracking(targetSum, k, sum, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 注意i+1调整startIndex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            sum <span style="color:#f92672">-=</span> i; <span style="color:#75715e">// 回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            path.pop_back(); <span style="color:#75715e">// 回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> combinationSum3(<span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        result.clear(); <span style="color:#75715e">// 可以不加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        path.clear();   <span style="color:#75715e">// 可以不加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        backtracking(n, k, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="3电话号码的字母组合">3.电话号码的字母组合
</h3><p><a class="link" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> string letterMap[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;def&#34;</span>, <span style="color:#75715e">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;ghi&#34;</span>, <span style="color:#75715e">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;jkl&#34;</span>, <span style="color:#75715e">// 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;mno&#34;</span>, <span style="color:#75715e">// 6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;pqrs&#34;</span>, <span style="color:#75715e">// 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;tuv&#34;</span>, <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;wxyz&#34;</span>, <span style="color:#75715e">// 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>    string s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> digits, <span style="color:#66d9ef">int</span> index) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">==</span> digits.size()) {
</span></span><span style="display:flex;"><span>            result.push_back(s);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> digit <span style="color:#f92672">=</span> digits[index] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;        <span style="color:#75715e">// 将index指向的数字转为int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        string letters <span style="color:#f92672">=</span> letterMap[digit];      <span style="color:#75715e">// 取数字对应的字符集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> letters.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            s.push_back(letters[i]);            <span style="color:#75715e">// 处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            backtracking(digits, index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);    <span style="color:#75715e">// 递归，注意index+1，一下层要处理下一个数字了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            s.pop_back();                       <span style="color:#75715e">// 回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> letterCombinations(string digits) {
</span></span><span style="display:flex;"><span>        s.clear();
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (digits.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        backtracking(digits, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(3^m * 4^n)，其中 m 是对应四个字母的数字个数，n 是对应三个字母的数字个数</li>
<li>空间复杂度: O(3^m * 4^n)</li>
</ul>
<h3 id="4组合总和">4.组合总和
</h3><p><a class="link" href="https://leetcode.cn/problems/combination-sum/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/combination-sum/</a></p>
<p>数组中和为target的组合。数组无重复，可以重复被选取。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> candidates, <span style="color:#66d9ef">int</span> target, <span style="color:#66d9ef">int</span> sum, <span style="color:#66d9ef">int</span> startIndex) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">&gt;</span> target) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">==</span> target) {
</span></span><span style="display:flex;"><span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;</span> candidates.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> candidates[i];
</span></span><span style="display:flex;"><span>            path.push_back(candidates[i]);
</span></span><span style="display:flex;"><span>            backtracking(candidates, target, sum, i); <span style="color:#75715e">// 不用i+1了，表示可以重复读取当前的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            sum <span style="color:#f92672">-=</span> candidates[i];
</span></span><span style="display:flex;"><span>            path.pop_back();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> combinationSum(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> candidates, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        backtracking(candidates, target, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)，注意这只是复杂度的上界，因为剪枝的存在，真实的时间复杂度远小于此</li>
<li>空间复杂度: O(target)</li>
</ul>
<h3 id="5组合总和">5.组合总和Ⅱ
</h3><p><a class="link" href="https://leetcode.cn/problems/combination-sum-ii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/combination-sum-ii/description/</a></p>
<p>数组有重复数字，不能重复使用数组的元素。</p>
<p><strong>用used数据记录数组使用情况</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> candidates, <span style="color:#66d9ef">int</span> target, <span style="color:#66d9ef">int</span> sum, <span style="color:#66d9ef">int</span> startIndex, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&amp;</span> used) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">==</span> target) {
</span></span><span style="display:flex;"><span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;</span> candidates.size() <span style="color:#f92672">&amp;&amp;</span> sum <span style="color:#f92672">+</span> candidates[i] <span style="color:#f92672">&lt;=</span> target; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 要对同一树层使用过的元素进行跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> candidates[i] <span style="color:#f92672">==</span> candidates[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;&amp;</span> used[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> false) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> candidates[i];
</span></span><span style="display:flex;"><span>            path.push_back(candidates[i]);
</span></span><span style="display:flex;"><span>            used[i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            backtracking(candidates, target, sum, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, used); <span style="color:#75715e">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            used[i] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">-=</span> candidates[i];
</span></span><span style="display:flex;"><span>            path.pop_back();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> combinationSum2(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> candidates, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> used(candidates.size(), false);
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 首先把给candidates排序，让其相同的元素都挨在一起。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        sort(candidates.begin(), candidates.end());
</span></span><span style="display:flex;"><span>        backtracking(candidates, target, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, used);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="6分割回文串">6.分割回文串
</h3><p><a class="link" href="https://leetcode.cn/problems/palindrome-partitioning/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/palindrome-partitioning/description/</a></p>
<p>判断字符串区间[startIndex,i]是否是回文</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> path; <span style="color:#75715e">// 放已经回文的子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span> (<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> startIndex) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (startIndex <span style="color:#f92672">&gt;=</span> s.size()) {
</span></span><span style="display:flex;"><span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isPalindrome(s, startIndex, i)) {   <span style="color:#75715e">// 是回文子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 获取[startIndex,i]在s中的子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                string str <span style="color:#f92672">=</span> s.substr(startIndex, i <span style="color:#f92672">-</span> startIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                path.push_back(str);
</span></span><span style="display:flex;"><span>                backtracking(s, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 寻找i+1为起始位置的子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                path.pop_back(); <span style="color:#75715e">// 回溯过程，弹出本次已经添加的子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isPalindrome</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start, j <span style="color:#f92672">=</span> end; i <span style="color:#f92672">&lt;</span> j; i<span style="color:#f92672">++</span>, j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">!=</span> s[j]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;</span> partition(string s) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        backtracking(s, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="7复原ip地址">7.复原IP地址
</h3><p><a class="link" href="https://leetcode.cn/problems/restore-ip-addresses/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/restore-ip-addresses/description/</a></p>
<p>判断字符串区间的是否是有效IP地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> result;<span style="color:#75715e">// 记录结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(string<span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> startIndex, <span style="color:#66d9ef">int</span> pointNum) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pointNum <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) { <span style="color:#75715e">// 逗点数量为3时，分隔结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 判断第四段子字符串是否合法，如果合法就放进result中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (isValid(s, startIndex, s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>                result.push_back(s);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isValid(s, startIndex, i)) { <span style="color:#75715e">// 判断 [startIndex,i] 这个区间的子串是否合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                s.insert(s.begin() <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> , <span style="color:#e6db74">&#39;.&#39;</span>);  <span style="color:#75715e">// 在i的后面插入一个逗点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                pointNum<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                backtracking(s, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, pointNum);   <span style="color:#75715e">// 插入逗点之后下一个子串的起始位置为i+2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                pointNum<span style="color:#f92672">--</span>;                         <span style="color:#75715e">// 回溯
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                s.erase(s.begin() <span style="color:#f92672">+</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);         <span style="color:#75715e">// 回溯删掉逗点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span>; <span style="color:#75715e">// 不合法，直接结束本层循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isValid</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&gt;</span> end) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s[start] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> start <span style="color:#f92672">!=</span> end) { <span style="color:#75715e">// 0开头的数字不合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start; i <span style="color:#f92672">&lt;=</span> end; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">||</span> s[i] <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;0&#39;</span>) { <span style="color:#75715e">// 遇到非数字字符不合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            num <span style="color:#f92672">=</span> num <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> (s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (num <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">255</span>) { <span style="color:#75715e">// 如果大于255了不合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> restoreIpAddresses(string s) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s.size() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">||</span> s.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#66d9ef">return</span> result; <span style="color:#75715e">// 算是剪枝了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        backtracking(s, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(3^4)，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式，则搜索树的最大深度为4，每个节点最多有3个子节点。</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="8子集">8.子集
</h3><p><a class="link" href="https://leetcode.cn/problems/subsets/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/subsets/description/</a></p>
<p><strong>组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p>
<p>数组元素不重复，结果不能重复</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> startIndex) {
</span></span><span style="display:flex;"><span>        result.push_back(path); <span style="color:#75715e">// 收集子集，要放在终止添加的上面，否则会漏掉自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (startIndex <span style="color:#f92672">&gt;=</span> nums.size()) { <span style="color:#75715e">// 终止条件可以不加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            path.push_back(nums[i]);
</span></span><span style="display:flex;"><span>            backtracking(nums, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            path.pop_back();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> subsets(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        backtracking(nums, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="9子集">9.子集Ⅱ
</h3><p><a class="link" href="https://leetcode.cn/problems/subsets-ii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/subsets-ii/description/</a></p>
<p><strong>哈希表记录元素有没有被使用</strong>。同一树层上一个元素被使用过则跳过。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> startIndex) {
</span></span><span style="display:flex;"><span>        result.push_back(path);
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> uset;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (uset.find(nums[i]) <span style="color:#f92672">!=</span> uset.end()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            uset.insert(nums[i]);
</span></span><span style="display:flex;"><span>            path.push_back(nums[i]);
</span></span><span style="display:flex;"><span>            backtracking(nums, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            path.pop_back();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>z
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> subsetsWithDup(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        sort(nums.begin(), nums.end()); <span style="color:#75715e">// 去重需要排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        backtracking(nums, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="10递增子序列">10.递增子序列
</h3><p><a class="link" href="https://leetcode.cn/problems/non-decreasing-subsequences/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> startIndex) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (path.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 注意这里不要加return，要取树上的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> uset; <span style="color:#75715e">// 使用set对本层元素进行去重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startIndex; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">!</span>path.empty() <span style="color:#f92672">&amp;&amp;</span> nums[i] <span style="color:#f92672">&lt;</span> path.back())
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">||</span> uset.find(nums[i]) <span style="color:#f92672">!=</span> uset.end()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            uset.insert(nums[i]); <span style="color:#75715e">// 记录这个元素在本层用过了，本层后面不能再用了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            path.push_back(nums[i]);
</span></span><span style="display:flex;"><span>            backtracking(nums, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            path.pop_back();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> findSubsequences(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        backtracking(nums, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * 2^n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="11全排列">11.全排列
</h3><p><a class="link" href="https://leetcode.cn/problems/permutations/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/permutations/description/</a></p>
<p>数组记录元素是否使用过。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span> (vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&amp;</span> used) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 此时说明找到了一组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (path.size() <span style="color:#f92672">==</span> nums.size()) {
</span></span><span style="display:flex;"><span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (used[i] <span style="color:#f92672">==</span> true) <span style="color:#66d9ef">continue</span>; <span style="color:#75715e">// path里已经收录的元素，直接跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            used[i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            path.push_back(nums[i]);
</span></span><span style="display:flex;"><span>            backtracking(nums, used);
</span></span><span style="display:flex;"><span>            path.pop_back();
</span></span><span style="display:flex;"><span>            used[i] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> permute(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> used(nums.size(), false);
</span></span><span style="display:flex;"><span>        backtracking(nums, used);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n!)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="12全排列">12.全排列Ⅱ
</h3><p><a class="link" href="https://leetcode.cn/problems/permutations-ii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/permutations-ii/description/</a></p>
<p>used数组记录。同一树枝没使用过存入。该元素与上一元素相等且同一树层使用过跳过。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span> (vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&amp;</span> used) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 此时说明找到了一组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (path.size() <span style="color:#f92672">==</span> nums.size()) {
</span></span><span style="display:flex;"><span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// used[i - 1] == false，说明同一树层nums[i - 1]使用过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 如果同一树层nums[i - 1]使用过则直接跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> nums[i] <span style="color:#f92672">==</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;&amp;</span> used[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> false) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (used[i] <span style="color:#f92672">==</span> false) {
</span></span><span style="display:flex;"><span>                used[i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                path.push_back(nums[i]);
</span></span><span style="display:flex;"><span>                backtracking(nums, used);
</span></span><span style="display:flex;"><span>                path.pop_back();
</span></span><span style="display:flex;"><span>                used[i] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> permuteUnique(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        path.clear();
</span></span><span style="display:flex;"><span>        sort(nums.begin(), nums.end()); <span style="color:#75715e">// 排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> used(nums.size(), false);
</span></span><span style="display:flex;"><span>        backtracking(nums, used);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素
</span></span></span></code></pre></div><ul>
<li>时间复杂度: O(n! * n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="13重新安排行程">13.重新安排行程
</h3><p><a class="link" href="https://leetcode.cn/problems/reconstruct-itinerary/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/reconstruct-itinerary/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>unordered_map<span style="color:#f92672">&lt;</span>string, map<span style="color:#f92672">&lt;</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> targets;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">backtracking</span>(<span style="color:#66d9ef">int</span> ticketNum, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> result) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result.size() <span style="color:#f92672">==</span> ticketNum <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> target : targets[result[result.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (target.second <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> ) { <span style="color:#75715e">// 记录到达机场是否飞过了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result.push_back(target.first);
</span></span><span style="display:flex;"><span>            target.second<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (backtracking(ticketNum, result)) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            result.pop_back();
</span></span><span style="display:flex;"><span>            target.second<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> findItinerary(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;&amp;</span> tickets) {
</span></span><span style="display:flex;"><span>        targets.clear();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> vec : tickets) {
</span></span><span style="display:flex;"><span>            targets[vec[<span style="color:#ae81ff">0</span>]][vec[<span style="color:#ae81ff">1</span>]]<span style="color:#f92672">++</span>; <span style="color:#75715e">// 记录映射关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        result.push_back(<span style="color:#e6db74">&#34;JFK&#34;</span>); <span style="color:#75715e">// 起始机场
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        backtracking(tickets.size(), result);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>优先级队列存储到达地，DFS</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span>string, priority_queue<span style="color:#f92672">&lt;</span>string, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>, std<span style="color:#f92672">::</span>greater<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;&gt;</span> vec;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> curr) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (vec.count(curr) <span style="color:#f92672">&amp;&amp;</span> vec[curr].size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            string tmp <span style="color:#f92672">=</span> vec[curr].top();
</span></span><span style="display:flex;"><span>            vec[curr].pop();
</span></span><span style="display:flex;"><span>            dfs(move(tmp));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        stk.emplace_back(curr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> findItinerary(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;&amp;</span> tickets) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> it : tickets) {
</span></span><span style="display:flex;"><span>            vec[it[<span style="color:#ae81ff">0</span>]].emplace(it[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        dfs(<span style="color:#e6db74">&#34;JFK&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        reverse(stk.begin(), stk.end());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stk;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="14n皇后">14.N皇后
</h3><p><a class="link" href="https://leetcode.cn/problems/n-queens/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/n-queens/description/</a></p>
<p>同一树层为棋盘的行，每次验证有效就放进去。</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// n 为输入的棋盘大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// row 是当前递归到棋盘的第几行了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">backtracking</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> row, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> chessboard) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (row <span style="color:#f92672">==</span> n) {
</span></span><span style="display:flex;"><span>        result.push_back(chessboard);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> col <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; col <span style="color:#f92672">&lt;</span> n; col<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (isValid(row, col, chessboard, n)) { <span style="color:#75715e">// 验证合法就可以放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            chessboard[row][col] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Q&#39;</span>; <span style="color:#75715e">// 放置皇后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            backtracking(n, row <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, chessboard);
</span></span><span style="display:flex;"><span>            chessboard[row][col] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>; <span style="color:#75715e">// 回溯，撤销皇后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isValid</span>(<span style="color:#66d9ef">int</span> row, <span style="color:#66d9ef">int</span> col, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> chessboard, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> row; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 这是一个剪枝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (chessboard[i][col] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Q&#39;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查 45度角是否有皇后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> row <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> col <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>, j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (chessboard[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Q&#39;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查 135度角是否有皇后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> row <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> col <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">--</span>, j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (chessboard[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Q&#39;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;</span> solveNQueens(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        result.clear();
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> chessboard(n, std<span style="color:#f92672">::</span>string(n, <span style="color:#e6db74">&#39;.&#39;</span>));
</span></span><span style="display:flex;"><span>        backtracking(n, <span style="color:#ae81ff">0</span>, chessboard);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n!)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="15解数独">15.解数独
</h3><p><a class="link" href="https://leetcode.cn/problems/sudoku-solver/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/sudoku-solver/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> backtracking(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> board.size(); i<span style="color:#f92672">++</span>) {        <span style="color:#75715e">// 遍历行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> board[<span style="color:#ae81ff">0</span>].size(); j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (board[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">char</span> k <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>; k <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;9&#39;</span>; k<span style="color:#f92672">++</span>) {     <span style="color:#75715e">// (i, j) 这个位置放k是否合适
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> (isValid(i, j, k, board)) {
</span></span><span style="display:flex;"><span>                        board[i][j] <span style="color:#f92672">=</span> k;                <span style="color:#75715e">// 放置k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (backtracking(board)) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 如果找到合适一组立刻返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        board[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;              <span style="color:#75715e">// 回溯，撤销k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;  <span style="color:#75715e">// 9个数都试完了，都不行，那么就返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 遍历完没有返回false，说明找到了合适棋盘位置了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isValid</span>(<span style="color:#66d9ef">int</span> row, <span style="color:#66d9ef">int</span> col, <span style="color:#66d9ef">char</span> val, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 判断行里是否重复
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (board[row][i] <span style="color:#f92672">==</span> val) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 判断列里是否重复
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (board[j][col] <span style="color:#f92672">==</span> val) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> startRow <span style="color:#f92672">=</span> (row <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> startCol <span style="color:#f92672">=</span> (col <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> startRow; i <span style="color:#f92672">&lt;</span> startRow <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 判断9方格里是否重复
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> startCol; j <span style="color:#f92672">&lt;</span> startCol <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (board[i][j] <span style="color:#f92672">==</span> val ) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> solveSudoku(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board) {
</span></span><span style="display:flex;"><span>        backtracking(board);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="八贪心">八、贪心
</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<h3 id="1分发饼干">1.分发饼干
</h3><p><a class="link" href="https://leetcode.cn/problems/assign-cookies/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/assign-cookies/</a></p>
<p><strong>局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findContentChildren(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> g, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> s) {
</span></span><span style="display:flex;"><span>        sort(g.begin(), g.end());
</span></span><span style="display:flex;"><span>        sort(s.begin(), s.end());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 饼干数组的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> g.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) { <span style="color:#75715e">// 遍历胃口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> s[index] <span style="color:#f92672">&gt;=</span> g[i]) { <span style="color:#75715e">// 遍历饼干
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                result<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                index<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>小饼干先喂饱小胃口也可以</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findContentChildren(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> g, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> s) {
</span></span><span style="display:flex;"><span>        sort(g.begin(),g.end());
</span></span><span style="display:flex;"><span>        sort(s.begin(),s.end());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 饼干
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(index <span style="color:#f92672">&lt;</span> g.size() <span style="color:#f92672">&amp;&amp;</span> g[index] <span style="color:#f92672">&lt;=</span> s[i]){ <span style="color:#75715e">// 胃口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                index<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> index;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="2摆动序列">2.摆动序列
</h3><p><a class="link" href="https://leetcode.cn/problems/wiggle-subsequence/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/wiggle-subsequence/description/</a></p>
<p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p>
<p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> wiggleMaxLength(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> nums.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> curDiff <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 当前一对差值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> preDiff <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 前一对差值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 记录峰值个数，序列默认序列最右边有一个峰值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            curDiff <span style="color:#f92672">=</span> nums[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> nums[i];
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 出现峰值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> ((preDiff <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> curDiff <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">||</span> (preDiff <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> curDiff <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>                result<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                preDiff <span style="color:#f92672">=</span> curDiff; <span style="color:#75715e">// 注意这里，只在摆动变化的时候更新prediff
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>动规</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">1005</span>][<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">wiggleMaxLength</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        memset(dp, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> dp);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> i; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (nums[j] <span style="color:#f92672">&gt;</span> nums[i]) dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i][<span style="color:#ae81ff">1</span>], dp[j][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> i; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (nums[j] <span style="color:#f92672">&lt;</span> nums[i]) dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(dp[i][<span style="color:#ae81ff">0</span>], dp[j][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> max(dp[nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], dp[nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>
<p>设 dp 状态<code>dp[i][0]</code>，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度</p>
</li>
<li>
<p>设 dp 状态<code>dp[i][1]</code>，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度</p>
</li>
<li>
<p>时间复杂度：O(n^2)</p>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<h3 id="3最大子序和">3.最大子序和
</h3><p><a class="link" href="https://leetcode.cn/problems/maximum-subarray/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/maximum-subarray/</a></p>
<p><strong>贪心</strong></p>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>全局最优：选取最大“连续和”</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxSubArray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> INT32_MIN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">+=</span> nums[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&gt;</span> result) { <span style="color:#75715e">// 取区间累计的最大值（相当于不断确定最大子序终止位置）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                result <span style="color:#f92672">=</span> count;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>动规</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxSubArray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(nums.size(), <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// dp[i]表示包括i之前的最大连续子序列和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> nums[i], nums[i]); <span style="color:#75715e">// 状态转移公式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (dp[i] <span style="color:#f92672">&gt;</span> result) result <span style="color:#f92672">=</span> dp[i]; <span style="color:#75715e">// result 保存dp[i]的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="4买卖股票的最佳时机">4.买卖股票的最佳时机Ⅱ
</h3><p><a class="link" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p>
<p>只有一只股票、当前只有买股票或者卖股票的操作、想获得利润至少要两天为一个交易单元。</p>
<p><strong>贪心</strong></p>
<p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> prices.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">+=</span> max(prices[i] <span style="color:#f92672">-</span> prices[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>动规</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// dp[i][1]第i天持有的最多现金
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// dp[i][0]第i天持有股票后的最多现金
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> prices.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(n, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> prices[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">// 持股票
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第i天持股票所剩最多现金 = max(第i-1天持股票所剩现金, 第i-1天持现金-买第i天的股票)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> prices[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第i天持有最多现金 = max(第i-1天持有的最多现金，第i-1天持有股票的最多现金+第i天卖出股票)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> prices[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>(dp[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], dp[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<h3 id="5跳跃游戏">5.跳跃游戏
</h3><p><a class="link" href="https://leetcode.cn/problems/jump-game/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/jump-game/description/</a></p>
<p>不管跳几步，转化为跳跃覆盖范围。</p>
<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> canJump(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cover <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 只有一个元素，就是能达到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> cover; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 注意这里是小于等于cover
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cover <span style="color:#f92672">=</span> max(i <span style="color:#f92672">+</span> nums[i], cover);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (cover <span style="color:#f92672">&gt;=</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 说明可以覆盖到终点了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="6跳跃游戏">6.跳跃游戏Ⅱ
</h3><p><a class="link" href="https://leetcode.cn/problems/jump-game-ii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/jump-game-ii/description/</a></p>
<p>需要记录步数。</p>
<p>当达到了当前覆盖的最远距离下标时，步数就要加一，并且更新最远覆盖距离。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> jump(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> curDistance <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;    <span style="color:#75715e">// 当前覆盖最远距离下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;            <span style="color:#75715e">// 记录走的最大步数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> nextDistance <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;   <span style="color:#75715e">// 下一步覆盖最远距离下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            nextDistance <span style="color:#f92672">=</span> max(nums[i] <span style="color:#f92672">+</span> i, nextDistance);  <span style="color:#75715e">// 更新下一步覆盖最远距离下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> curDistance) {                         <span style="color:#75715e">// 遇到当前覆盖最远距离下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                ans<span style="color:#f92672">++</span>;                                  <span style="color:#75715e">// 需要走下一步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                curDistance <span style="color:#f92672">=</span> nextDistance;             <span style="color:#75715e">// 更新当前覆盖最远距离下标（相当于加油了）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (nextDistance <span style="color:#f92672">&gt;=</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">break</span>;  <span style="color:#75715e">// 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="7k次取反后最大化的数组和">7.K次取反后最大化的数组和
</h3><p><a class="link" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/</a></p>
<p>局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> abs(a) <span style="color:#f92672">&gt;</span> abs(b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> largestSumAfterKNegations(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, <span style="color:#66d9ef">int</span> K) {
</span></span><span style="display:flex;"><span>        sort(A.begin(), A.end(), cmp);       <span style="color:#75715e">// 第一步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> A.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 第二步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (A[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> K <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                A[i] <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                K<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (K <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) A[A.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 第三步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> a : A) result <span style="color:#f92672">+=</span> a;        <span style="color:#75715e">// 第四步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(nlogn)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="8加油站">8.加油站
</h3><p><a class="link" href="https://leetcode.cn/problems/gas-station/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/gas-station/</a></p>
<p><strong>局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> canCompleteCircuit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> gas, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> cost) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> curSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> totalSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> gas.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            curSum <span style="color:#f92672">+=</span> gas[i] <span style="color:#f92672">-</span> cost[i];
</span></span><span style="display:flex;"><span>            totalSum <span style="color:#f92672">+=</span> gas[i] <span style="color:#f92672">-</span> cost[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (curSum <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {   <span style="color:#75715e">// 当前累加rest[i]和 curSum一旦小于0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                start <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 起始位置更新为i+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                curSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;     <span style="color:#75715e">// curSum从0开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (totalSum <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 说明怎么走都不可能跑一圈了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> start;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="9分发糖果">9.分发糖果
</h3><p><a class="link" href="https://leetcode.cn/problems/candy/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/candy/description/</a></p>
<ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<p>这样从局部最优推出了全局最优</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> candy(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> ratings) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> candyVec(ratings.size(), <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从前向后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> ratings.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ratings[i] <span style="color:#f92672">&gt;</span> ratings[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) candyVec[i] <span style="color:#f92672">=</span> candyVec[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从后向前
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> ratings.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ratings[i] <span style="color:#f92672">&gt;</span> ratings[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] ) {
</span></span><span style="display:flex;"><span>                candyVec[i] <span style="color:#f92672">=</span> max(candyVec[i], candyVec[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 统计结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> candyVec.size(); i<span style="color:#f92672">++</span>) result <span style="color:#f92672">+=</span> candyVec[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="10柠檬水找零">10.柠檬水找零
</h3><p><a class="link" href="https://leetcode.cn/problems/lemonade-change/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/lemonade-change/description/</a></p>
<p>局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> lemonadeChange(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> bills) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> five <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, ten <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, twenty <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> bill : bills) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 情况一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (bill <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) five<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 情况二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (bill <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (five <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>                ten<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                five<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 情况三
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (bill <span style="color:#f92672">==</span> <span style="color:#ae81ff">20</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (five <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ten <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    five<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                    ten<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                    twenty<span style="color:#f92672">++</span>; <span style="color:#75715e">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (five <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>                    five <span style="color:#f92672">-=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>                    twenty<span style="color:#f92672">++</span>; <span style="color:#75715e">// 同理，这行代码也可以删了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="11根据身高重建队列">11.根据身高重建队列
</h3><p><a class="link" href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/queue-reconstruction-by-height/description/</a></p>
<p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong></p>
<p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p>
<p><strong>使用数组</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> b[<span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> b[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> reconstructQueue(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> people) {
</span></span><span style="display:flex;"><span>        sort (people.begin(), people.end(), cmp);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> que;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> people.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> position <span style="color:#f92672">=</span> people[i][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            que.insert(que.begin() <span style="color:#f92672">+</span> position, people[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> que;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(nlog n + n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>vector（动态数组）来insert，是费时的。</p>
<p><strong>使用链表</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 身高从大到小排（身高相同k小的站前面）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> b[<span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> b[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> reconstructQueue(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> people) {
</span></span><span style="display:flex;"><span>        sort (people.begin(), people.end(), cmp);
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> que; <span style="color:#75715e">// list底层是链表实现，插入效率比vector高的多
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> people.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> position <span style="color:#f92672">=</span> people[i][<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 插入到下标为position的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;::</span>iterator it <span style="color:#f92672">=</span> que.begin();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (position<span style="color:#f92672">--</span>) { <span style="color:#75715e">// 寻找在插入位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                it<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            que.insert(it, people[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>(que.begin(), que.end());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(nlog n + n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>首先vector的底层实现也是普通数组</strong>。</p>
<p>vector的大小有两个维度一个是size一个是capicity，size就是我们平时用来遍历vector时候用的。而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size。</p>
<p>当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴漏的size其实仅仅是+1。</p>
<p>vector底层实现是普通数组，怎么扩容的？</p>
<p>就是重新申请一个二倍于原数组大小的数组，然后把数据都拷贝过去，并释放原数组内存。</p>
<h3 id="12用最少数量的箭引爆气球">12.用最少数量的箭引爆气球
</h3><p><a class="link" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/</a></p>
<p>局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> cmp(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findMinArrowShots(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> points) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (points.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        sort(points.begin(), points.end(), cmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// points 不为空至少需要一支箭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> points.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (points[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> points[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]) {  <span style="color:#75715e">// 气球i和气球i-1不挨着，注意这里不是&gt;=
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                result<span style="color:#f92672">++</span>; <span style="color:#75715e">// 需要一支箭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 气球i和气球i-1挨着
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                points[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> min(points[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], points[i][<span style="color:#ae81ff">1</span>]); <span style="color:#75715e">// 更新重叠气球最小右边界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(nlog n)，因为有一个快排</li>
<li>空间复杂度：O(1)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li>
</ul>
<h3 id="13无重叠区间">13.无重叠区间
</h3><p><a class="link" href="https://leetcode.cn/problems/non-overlapping-intervals/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/non-overlapping-intervals/</a></p>
<p><strong>右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 按照区间右边界排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> cmp (<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">eraseOverlapIntervals</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> intervals) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (intervals.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        sort(intervals.begin(), intervals.end(), cmp);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 记录非交叉区间的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> end <span style="color:#f92672">=</span> intervals[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 记录区间分割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> intervals.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (end <span style="color:#f92672">&lt;=</span> intervals[i][<span style="color:#ae81ff">0</span>]) {
</span></span><span style="display:flex;"><span>                end <span style="color:#f92672">=</span> intervals[i][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> intervals.size() <span style="color:#f92672">-</span> count;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(nlog n) ，有一个快排</li>
<li>空间复杂度：O(n)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li>
</ul>
<p><strong>左边界排序</strong> 左边界排序我们就是直接求 重叠的区间，count为记录重叠区间数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> cmp (<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">// 改为左边界排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">eraseOverlapIntervals</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> intervals) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (intervals.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        sort(intervals.begin(), intervals.end(), cmp);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 注意这里从0开始，因为是记录重叠区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> end <span style="color:#f92672">=</span> intervals[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 记录区间分割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> intervals.size(); i<span style="color:#f92672">++</span>) {   
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (intervals[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;=</span> end)  end <span style="color:#f92672">=</span> intervals[i][<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 无重叠的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 重叠情况 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                end <span style="color:#f92672">=</span> min(end, intervals[i][<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="14划分字母区间">14.划分字母区间
</h3><p><a class="link" href="https://leetcode.cn/problems/partition-labels/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/partition-labels/description/</a></p>
<p><strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> partitionLabels(string S) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> hash[<span style="color:#ae81ff">27</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>}; <span style="color:#75715e">// i为字符，hash[i]为字符出现的最后位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> S.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 统计每一个字符最后出现的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            hash[S[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> S.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> max(right, hash[S[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>]); <span style="color:#75715e">// 找到字符出现的最远边界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> right) {
</span></span><span style="display:flex;"><span>                result.push_back(right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                left <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，使用的hash数组是固定大小</li>
</ul>
<h3 id="15合并区间">15.合并区间
</h3><p><a class="link" href="https://leetcode.cn/problems/merge-intervals/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/merge-intervals/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> merge(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> intervals) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (intervals.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> result; <span style="color:#75715e">// 区间集合为空直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 排序的参数使用了lambda表达式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        sort(intervals.begin(), intervals.end(), [](<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b){<span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">0</span>];});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        result.push_back(intervals[<span style="color:#ae81ff">0</span>]); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> intervals.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (result.back()[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> intervals[i][<span style="color:#ae81ff">0</span>]) { <span style="color:#75715e">// 发现重叠区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                result.back()[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(result.back()[<span style="color:#ae81ff">1</span>], intervals[i][<span style="color:#ae81ff">1</span>]); 
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                result.push_back(intervals[i]); <span style="color:#75715e">// 区间不重叠 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(nlogn)</li>
<li>空间复杂度: O(logn)，排序需要的空间开销</li>
</ul>
<h3 id="16单调递增的数字">16.单调递增的数字
</h3><p><a class="link" href="https://leetcode.cn/problems/monotone-increasing-digits/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/monotone-increasing-digits/description/</a></p>
<p>从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> monotoneIncreasingDigits(<span style="color:#66d9ef">int</span> N) {
</span></span><span style="display:flex;"><span>        string strNum <span style="color:#f92672">=</span> to_string(N);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// flag用来标记赋值9从哪里开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> strNum.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> strNum.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (strNum[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> strNum[i] ) {
</span></span><span style="display:flex;"><span>                flag <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                strNum[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> flag; i <span style="color:#f92672">&lt;</span> strNum.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            strNum[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;9&#39;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">stoi</span>(strNum);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)，n 为数字长度</li>
<li>空间复杂度：O(n)，需要一个字符串，转化为字符串操作更方便</li>
</ul>
<h3 id="17监控二叉树">17.监控二叉树
</h3><p><a class="link" href="https://leetcode.cn/problems/binary-tree-cameras/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/binary-tree-cameras/</a></p>
<p><strong>从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p>
<p>分别有三个数字来表示：</p>
<ul>
<li>0：该节点无覆盖</li>
<li>1：本节点有摄像头</li>
<li>2：本节点有覆盖</li>
</ul>
<p><strong>空节点的状态是有覆盖</strong></p>
<ul>
<li>
<p>情况1：左右节点都有覆盖</p>
</li>
<li>
<p>情况2：左右节点至少有一个无覆盖的情况</p>
</li>
</ul>
<p>如果是以下情况，则中间节点（父节点）应该放摄像头：</p>
<ul>
<li>
<p>left == 0 &amp;&amp; right == 0 左右节点无覆盖</p>
</li>
<li>
<p>left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</p>
</li>
<li>
<p>left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</p>
</li>
<li>
<p>left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</p>
</li>
<li>
<p>left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</p>
</li>
<li>
<p>情况3：左右节点至少有一个有摄像头</p>
</li>
</ul>
<p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p>
<ul>
<li>
<p>left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</p>
</li>
<li>
<p>left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</p>
</li>
<li>
<p>left == 1 &amp;&amp; right == 1 左右节点都有摄像头</p>
</li>
<li>
<p>情况4：头结点没有覆盖</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> cur) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 空节点，该节点有覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> traversal(cur<span style="color:#f92672">-&gt;</span>left);    <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> traversal(cur<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 情况1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 左右节点都有覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 情况2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 0 &amp;&amp; right == 0 左右节点无覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> right <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            result<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 情况3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// left == 1 &amp;&amp; right == 1 左右节点都有摄像头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 其他情况前段代码均已覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> right <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这个 return -1 逻辑不会走到这里。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minCameraCover(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 情况4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (traversal(root) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) { <span style="color:#75715e">// root 无覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)，需要遍历二叉树上的每个节点</li>
<li>空间复杂度: O(n)</li>
</ul>
<h2 id="九动态规划">九、动态规划
</h2><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>debug：<strong>把dp数组打印出来</strong></p>
<h3 id="1斐波那契数">1.斐波那契数
</h3><p><a class="link" href="https://leetcode.cn/problems/fibonacci-number/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/fibonacci-number/description/</a></p>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<p><strong>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fib(<span style="color:#66d9ef">int</span> N) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (N <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> N;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> N; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> dp[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sum;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>递归</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fib(<span style="color:#66d9ef">int</span> N) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (N <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> N;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>(N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(N <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(2^n)</li>
<li>空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间</li>
</ul>
<h3 id="2爬楼梯">2.爬楼梯
</h3><p><a class="link" href="https://leetcode.cn/problems/climbing-stairs/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/climbing-stairs/description/</a></p>
<p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p>
<p>递推公式dp[i] = dp[i - 1] + dp[i - 2]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> climbStairs(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> n; <span style="color:#75715e">// 因为下面直接对dp[2]操作了，防止空指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 注意i是从3开始的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<p><strong>优化空间</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> climbStairs(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>            dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>            dp[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> sum;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h3 id="3使用最小花费爬楼梯">3.使用最小花费爬楼梯
</h3><p><a class="link" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/min-cost-climbing-stairs/description/</a></p>
<p><strong>dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]</strong>。</p>
<p>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minCostClimbingStairs(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> cost) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(cost.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> cost.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> min(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> cost[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> cost[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[cost.size()];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="4不同路径">4.不同路径
</h3><p><a class="link" href="https://leetcode.cn/problems/unique-paths/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/unique-paths/description/</a></p>
<p>dp[i][j]：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p>
<p>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> uniquePaths(<span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(m, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(n, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(m × n)</li>
<li>空间复杂度：O(m × n)</li>
</ul>
<h3 id="5不同路径">5.不同路径Ⅱ
</h3><p><a class="link" href="https://leetcode.cn/problems/unique-paths-ii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/unique-paths-ii/description/</a></p>
<p>有障碍物的情况下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> uniquePathsWithObstacles(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> obstacleGrid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> obstacleGrid.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> obstacleGrid[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (obstacleGrid[m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> obstacleGrid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">//如果在起点或终点出现了障碍，直接返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(m, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(n, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">&amp;&amp;</span> obstacleGrid[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">++</span>) dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> obstacleGrid[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; j<span style="color:#f92672">++</span>) dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (obstacleGrid[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n × m)，n、m 分别为obstacleGrid 长度和宽度</li>
<li>空间复杂度：O(n × m)</li>
</ul>
<h3 id="6整数拆分">6.整数拆分
</h3><p><a class="link" href="https://leetcode.cn/problems/integer-break/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/integer-break/description/</a></p>
<p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<p>dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> integerBreak(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; i <span style="color:#f92672">&lt;=</span> n ; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                dp[i] <span style="color:#f92672">=</span> max(dp[i], max((i <span style="color:#f92672">-</span> j) <span style="color:#f92672">*</span> j, dp[i <span style="color:#f92672">-</span> j] <span style="color:#f92672">*</span> j));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<h3 id="7不同的二叉搜索树">7.不同的二叉搜索树
</h3><p><a class="link" href="https://leetcode.cn/problems/unique-binary-search-trees/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/unique-binary-search-trees/description/</a></p>
<p><img src="/imgs/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/20210107093226241.png"
	
	
	
	loading="lazy"
	
		alt="96.不同的二叉搜索树2"
	
	
></p>
<p><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p>
<p>dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numTrees(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                dp[i] <span style="color:#f92672">+=</span> dp[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> dp[i <span style="color:#f92672">-</span> j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<h3 id="8-01背包理论基础">8. 01背包理论基础
</h3><p><img src="/imgs/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/202309181640514.png"
	
	
	
	loading="lazy"
	
		alt="416.分割等和子集1"
	
	
></p>
<p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p>
<p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p>
<h4 id="二维dp数组01背包">二维dp数组01背包
</h4><p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<ul>
<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。</li>
<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>所以<strong>递归公式</strong>： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<p><strong>dp数组如何初始化:</strong></p>
<p>如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。</p>
<p>j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<p><strong>先遍历物品</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// weight数组的大小 就是物品个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> weight.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> bagweight; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">&lt;</span> weight[i]) dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> weight[i]] <span style="color:#f92672">+</span> value[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>先遍历背包</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// weight数组的大小 就是物品个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> bagweight; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> weight.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">&lt;</span> weight[i]) dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> weight[i]] <span style="color:#f92672">+</span> value[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="一维dp数组滚动数组">一维dp数组（滚动数组）
</h4><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</span></span></code></pre></div><p>一维dp遍历的时候，背包是从大到小。<strong>倒序遍历是为了保证物品i只被放入一次！</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_1_wei_bag_problem</span>() {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> weight <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>};
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> value <span style="color:#f92672">=</span> {<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> bagWeight <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(bagWeight <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> weight.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> bagWeight; j <span style="color:#f92672">&gt;=</span> weight[i]; j<span style="color:#f92672">--</span>) { <span style="color:#75715e">// 遍历背包容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j <span style="color:#f92672">-</span> weight[i]] <span style="color:#f92672">+</span> value[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> dp[bagWeight] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    test_1_wei_bag_problem();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="9分割等和子集">9.分割等和子集
</h3><p><a class="link" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p>
<ul>
<li>背包的体积为sum / 2。能否出现总和为 sum / 2 的子集。</li>
</ul>
<p><strong>01背包</strong></p>
<ul>
<li>
<p><strong>dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong>。</p>
</li>
<li>
<p>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p>
</li>
<li>
<p>dp[0]=0</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> canPartition(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// dp[i]中的i表示背包内总和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(<span style="color:#ae81ff">10001</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> nums[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 也可以使用库函数一步求和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// int sum = accumulate(nums.begin(), nums.end(), 0);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> sum <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 开始 01背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> target; j <span style="color:#f92672">&gt;=</span> nums[i]; j<span style="color:#f92672">--</span>) { <span style="color:#75715e">// 每一个元素一定是不可重复放入，所以从大到小遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j <span style="color:#f92672">-</span> nums[i]] <span style="color:#f92672">+</span> nums[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 集合中的元素正好可以凑成总和target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (dp[target] <span style="color:#f92672">==</span> target) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)，虽然dp数组大小为一个常数，但是大常数</li>
</ul>
<h3 id="10最后一块石头的重量ii">10.最后一块石头的重量II
</h3><p><a class="link" href="https://leetcode.cn/problems/last-stone-weight-ii/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/last-stone-weight-ii/</a></p>
<p><strong>01背包</strong></p>
<p>分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lastStoneWeightII(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> stones) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(<span style="color:#ae81ff">15001</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> stones.size(); i<span style="color:#f92672">++</span>) sum <span style="color:#f92672">+=</span> stones[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> sum <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> stones.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> target; j <span style="color:#f92672">&gt;=</span> stones[i]; j<span style="color:#f92672">--</span>) { <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j <span style="color:#f92672">-</span> stones[i]] <span style="color:#f92672">+</span> stones[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum <span style="color:#f92672">-</span> dp[target] <span style="color:#f92672">-</span> dp[target];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(m × n) , m是石头总重量（准确的说是总重量的一半），n为石头块数</li>
<li>空间复杂度：O(m)</li>
</ul>
<h3 id="11目标和">11.目标和
</h3><p><a class="link" href="https://leetcode.cn/problems/target-sum/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/target-sum/</a></p>
<p>left组合 - right组合 = target。</p>
<p>left + right = sum，而sum是固定的。right = sum - left</p>
<p>公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。</p>
<p><strong>装满容量为left的背包，有几种方法</strong></p>
<p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p>
<p>dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<p>dp[0] =1</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findTargetSumWays(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> S) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) sum <span style="color:#f92672">+=</span> nums[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (abs(S) <span style="color:#f92672">&gt;</span> sum) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 此时没有方案
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((S <span style="color:#f92672">+</span> sum) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 此时没有方案
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> bagSize <span style="color:#f92672">=</span> (S <span style="color:#f92672">+</span> sum) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(bagSize <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> bagSize; j <span style="color:#f92672">&gt;=</span> nums[i]; j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>                dp[j] <span style="color:#f92672">+=</span> dp[j <span style="color:#f92672">-</span> nums[i]];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[bagSize];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n × m)，n为正数个数，m为背包容量</li>
<li>空间复杂度：O(m)，m为背包容量</li>
</ul>
<h3 id="12一和零">12.一和零
</h3><p><a class="link" href="https://leetcode.cn/problems/ones-and-zeroes/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/ones-and-zeroes/description/</a></p>
<p><strong>dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]</strong>。</p>
<p>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findMaxForm(vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> strs, <span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)); <span style="color:#75715e">// 默认初始化0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (string str : strs) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> oneNum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, zeroNum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">char</span> c : str) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) zeroNum<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> oneNum<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> m; i <span style="color:#f92672">&gt;=</span> zeroNum; i<span style="color:#f92672">--</span>) { <span style="color:#75715e">// 遍历背包容量且从后向前遍历！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n; j <span style="color:#f92672">&gt;=</span> oneNum; j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> max(dp[i][j], dp[i <span style="color:#f92672">-</span> zeroNum][j <span style="color:#f92672">-</span> oneNum] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[m][n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(kmn)，k 为strs的长度</li>
<li>空间复杂度: O(mn)</li>
</ul>
<h3 id="13完全背包">13.完全背包
</h3><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_CompletePack</span>() {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> weight <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>};
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> value <span style="color:#f92672">=</span> {<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> bagWeight <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(bagWeight <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> weight.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> weight[i]; j <span style="color:#f92672">&lt;=</span> bagWeight; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j <span style="color:#f92672">-</span> weight[i]] <span style="color:#f92672">+</span> value[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> dp[bagWeight] <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    test_CompletePack();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="14零钱兑换ii">14.零钱兑换II
</h3><p><a class="link" href="https://leetcode.cn/problems/coin-change-ii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/coin-change-ii/description/</a></p>
<ul>
<li>dp[j]：凑成总金额j的货币组合数为dp[j]</li>
<li>dp[j] += dp[j - coins[i]];</li>
<li>dp[0] = 1</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> change(<span style="color:#66d9ef">int</span> amount, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> coins) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(amount <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> coins.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> coins[i]; j <span style="color:#f92672">&lt;=</span> amount; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dp[j] <span style="color:#f92672">+=</span> dp[j <span style="color:#f92672">-</span> coins[i]];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[amount];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(mn)，其中 m 是amount，n 是 coins 的长度</li>
<li>空间复杂度: O(m)</li>
</ul>
<h3 id="15组合总和">15.组合总和Ⅳ
</h3><p><a class="link" href="https://leetcode.cn/problems/combination-sum-iv/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/combination-sum-iv/description/</a></p>
<ul>
<li><strong>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</strong></li>
<li>dp[i] += dp[i - nums[j]];</li>
<li>dp[0]=1</li>
</ul>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> combinationSum4(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(target <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> target; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> nums.size(); j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">-</span> nums[j] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> dp[i] <span style="color:#f92672">&lt;</span> INT_MAX <span style="color:#f92672">-</span> dp[i <span style="color:#f92672">-</span> nums[j]]) {
</span></span><span style="display:flex;"><span>                    dp[i] <span style="color:#f92672">+=</span> dp[i <span style="color:#f92672">-</span> nums[j]];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[target];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(target * n)，其中 n 为 nums 的长度</li>
<li>空间复杂度: O(target)</li>
</ul>
<h3 id="16零钱兑换">16.零钱兑换
</h3><p><a class="link" href="https://leetcode.cn/problems/coin-change/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/coin-change/</a></p>
<ul>
<li><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></li>
<li>dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</li>
<li>凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;</li>
</ul>
<p>不强调组合还是排列，遍历顺序都可以</p>
<p>coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> coinChange(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> coins, <span style="color:#66d9ef">int</span> amount) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(amount <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, INT_MAX);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> coins.size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> coins[i]; j <span style="color:#f92672">&lt;=</span> amount; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (dp[j <span style="color:#f92672">-</span> coins[i]] <span style="color:#f92672">!=</span> INT_MAX) { <span style="color:#75715e">// 如果dp[j - coins[i]]是初始值则跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    dp[j] <span style="color:#f92672">=</span> min(dp[j <span style="color:#f92672">-</span> coins[i]] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, dp[j]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dp[amount] <span style="color:#f92672">==</span> INT_MAX) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[amount];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * amount)，其中 n 为 coins 的长度</li>
<li>空间复杂度: O(amount)</li>
</ul>
<p>遍历方式遍历背包放在外循环，遍历物品放在内循环也是可以的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> coinChange(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> coins, <span style="color:#66d9ef">int</span> amount) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(amount <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, INT_MAX);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> amount; i<span style="color:#f92672">++</span>) {  <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> coins.size(); j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">-</span> coins[j] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> dp[i <span style="color:#f92672">-</span> coins[j]] <span style="color:#f92672">!=</span> INT_MAX ) {
</span></span><span style="display:flex;"><span>                    dp[i] <span style="color:#f92672">=</span> min(dp[i <span style="color:#f92672">-</span> coins[j]] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, dp[i]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dp[amount] <span style="color:#f92672">==</span> INT_MAX) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[amount];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="17完全平方数">17.完全平方数
</h3><p><a class="link" href="https://leetcode.cn/problems/perfect-squares/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/perfect-squares/description/</a></p>
<ul>
<li><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></li>
<li>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</li>
</ul>
<p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j])</p>
<ul>
<li>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</li>
</ul>
<p><strong>本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numSquares(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, INT_MAX);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">*</span> j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dp[i] <span style="color:#f92672">=</span> min(dp[i <span style="color:#f92672">-</span> j <span style="color:#f92672">*</span> j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, dp[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * √n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<p>同样我在给出先遍历物品，在遍历背包的代码，一样的可以AC的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numSquares(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, INT_MAX);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">*</span> i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">*</span> i; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dp[j] <span style="color:#f92672">=</span> min(dp[j <span style="color:#f92672">-</span> i <span style="color:#f92672">*</span> i] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, dp[j]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="18单词拆分">18.单词拆分
</h3><p><a class="link" href="https://leetcode.cn/problems/word-break/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/word-break/description/</a></p>
<ul>
<li><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</li>
</ul>
<p>求的是排列数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> wordBreak(string s, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> wordDict) {
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> wordSet(wordDict.begin(), wordDict.end());
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> dp(s.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, false);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> s.size(); i<span style="color:#f92672">++</span>) {   <span style="color:#75715e">// 遍历背包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> i; j<span style="color:#f92672">++</span>) {       <span style="color:#75715e">// 遍历物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                string word <span style="color:#f92672">=</span> s.substr(j, i <span style="color:#f92672">-</span> j); <span style="color:#75715e">//substr(起始位置，截取的个数)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (wordSet.find(word) <span style="color:#f92672">!=</span> wordSet.end() <span style="color:#f92672">&amp;&amp;</span> dp[j]) {
</span></span><span style="display:flex;"><span>                    dp[i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[s.size()];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n^3)，因为substr返回子串的副本是O(n)的复杂度（这里的n是substring的长度）</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="19打家劫舍">19.打家劫舍
</h3><p><a class="link" href="https://leetcode.cn/problems/house-robber/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/house-robber/description/</a></p>
<ul>
<li><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</li>
<li>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</li>
<li>dp[0= nums[0]，dp[1] = max(nums[0], nums[1]);</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rob(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> nums[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(nums.size());
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(nums[<span style="color:#ae81ff">0</span>], nums[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> nums[i], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="20打家劫舍iii">20.打家劫舍III
</h3><p><a class="link" href="https://leetcode.cn/problems/house-robber-iii/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/house-robber-iii/description/</a></p>
<p><strong>树形dp</strong></p>
<p>后序遍历。</p>
<p>通过递归左节点，得到左节点偷与不偷的金钱。</p>
<p>通过递归右节点，得到右节点偷与不偷的金钱。</p>
<p>如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-&gt;val + left[0] + right[0];</p>
<p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rob(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> robTree(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>(result[<span style="color:#ae81ff">0</span>], result[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 长度为2的数组，0：不偷，1：偷
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> robTree(TreeNode<span style="color:#f92672">*</span> cur) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> left <span style="color:#f92672">=</span> robTree(cur<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> right <span style="color:#f92672">=</span> robTree(cur<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 偷cur，那么就不能偷左右节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> val1 <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">+</span> left[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> right[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> val2 <span style="color:#f92672">=</span> max(left[<span style="color:#ae81ff">0</span>], left[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> max(right[<span style="color:#ae81ff">0</span>], right[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {val2, val1};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)，每个节点只遍历了一次</li>
<li>空间复杂度：O(log n)，算上递推系统栈的空间</li>
</ul>
<h3 id="21买卖股票的最佳时机">21.买卖股票的最佳时机
</h3><p><a class="link" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
<p><strong>贪心</strong></p>
<p>因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> INT_MAX;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> prices.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            low <span style="color:#f92672">=</span> min(low, prices[i]);  <span style="color:#75715e">// 取最左最小价格
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result <span style="color:#f92672">=</span> max(result, prices[i] <span style="color:#f92672">-</span> low); <span style="color:#75715e">// 直接取最大区间利润
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>动态规划</strong></p>
<ul>
<li>
<p>dp[i][0] 表示第i天持有股票所得最多现金</p>
<p>dp[i][1] 表示第i天不持有股票所得最多现金</p>
</li>
<li>
<p>dp[i][0] = max(dp[i - 1][0], -prices[i]);</p>
<p>dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> prices.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(len, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> prices[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], <span style="color:#f92672">-</span>prices[i]);
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], prices[i] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="22买卖股票的最佳时机ii">22.买卖股票的最佳时机II
</h3><p><a class="link" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> prices.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(len, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> prices[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> prices[i]); <span style="color:#75715e">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> prices[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="23买卖股票的最佳时机iii">23.买卖股票的最佳时机III
</h3><p><a class="link" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</a></p>
<p>一天一共就有五个状态，</p>
<ol>
<li>没有操作 （其实我们也可以不设置这个状态）</li>
<li>第一次持有股票</li>
<li>第一次不持有股票</li>
<li>第二次持有股票</li>
<li>第二次不持有股票</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (prices.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(prices.size(), vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>prices[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>prices[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> prices.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> prices[i]);
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> prices[i]);
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> prices[i]);
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">4</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">+</span> prices[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[prices.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n × 5)</li>
</ul>
<h3 id="24买卖股票的最佳时机iv">24.买卖股票的最佳时机IV
</h3><p><a class="link" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<p><strong>除了0以外，偶数就是卖出，奇数就是买入</strong>。</p>
<p>至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(<span style="color:#66d9ef">int</span> k, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (prices.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(prices.size(), vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> k; j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>            dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>prices[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;</span> prices.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>                dp[i][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">-</span> prices[i]);
</span></span><span style="display:flex;"><span>                dp[i][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> prices[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[prices.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> k];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * k)，其中 n 为 prices 的长度</li>
<li>空间复杂度: O(n * k)</li>
</ul>
<h3 id="25最佳买卖股票时机含冷冻期">25.最佳买卖股票时机含冷冻期
</h3><p>dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。</p>
<ul>
<li>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li>
<li>不持有股票状态，这里就有两种卖出股票状态
<ul>
<li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li>
<li>状态三：今天卖出股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li>
</ul>
<p><img src="/imgs/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/202309181940098.png"
	
	
	
	loading="lazy"
	
		alt="img"
	
	
></p>
<p>j的状态为：</p>
<ul>
<li>0：状态一</li>
<li>1：状态二</li>
<li>2：状态三</li>
<li>3：状态四</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> prices.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(n, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> prices[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">// 持股票
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">-</span> prices[i], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> prices[i]));
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> prices[i];
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>(dp[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>], max(dp[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], dp[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="26买卖股票的最佳时机含手续费">26.买卖股票的最佳时机含手续费
</h3><p><a class="link" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p>
<p>dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxProfit(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices, <span style="color:#66d9ef">int</span> fee) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> prices.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(n, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> prices[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">// 持股票
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> prices[i]);
</span></span><span style="display:flex;"><span>            dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> prices[i] <span style="color:#f92672">-</span> fee);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>(dp[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], dp[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="27最长递增子序列">27.最长递增子序列
</h3><p><a class="link" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></p>
<ul>
<li>
<p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p>
</li>
<li>
<p>if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lengthOfLIS(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> nums.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(nums.size(), <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> i; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&gt;</span> nums[j]) dp[i] <span style="color:#f92672">=</span> max(dp[i], dp[j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dp[i] <span style="color:#f92672">&gt;</span> result) result <span style="color:#f92672">=</span> dp[i]; <span style="color:#75715e">// 取长的子序列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="28最长连续递增序列">28.最长连续递增序列
</h3><p><a class="link" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p>
<ul>
<li><strong>dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]</strong>。</li>
<li>dp[i] = dp[i - 1] + 1;</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findLengthOfLCIS(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(nums.size() ,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&gt;</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) { <span style="color:#75715e">// 连续记录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dp[i] <span style="color:#f92672">&gt;</span> result) result <span style="color:#f92672">=</span> dp[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="29最长重复子数组">29.最长重复子数组
</h3><p><a class="link" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p>
<ul>
<li>dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。</li>
<li>当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findLength(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums1, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums2) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp (nums1.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(nums2.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> nums1.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> nums2.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (nums1[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> nums2[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (dp[i][j] <span style="color:#f92672">&gt;</span> result) result <span style="color:#f92672">=</span> dp[i][j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n × m)，n 为A长度，m为B长度</li>
<li>空间复杂度：O(n × m)</li>
</ul>
<h3 id="30最长公共子序列">30.最长公共子序列
</h3><p><a class="link" href="https://leetcode.cn/problems/longest-common-subsequence/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/longest-common-subsequence/</a></p>
<ul>
<li>dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</li>
<li></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> longestCommonSubsequence(string text1, string text2) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(text1.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(text2.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> text1.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> text2.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (text1[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> text2[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j], dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[text1.size()][text2.size()];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * m)，其中 n 和 m 分别为 text1 和 text2 的长度</li>
<li>空间复杂度: O(n * m)</li>
</ul>
<h3 id="31最大子序和">31.最大子序和
</h3><p><a class="link" href="https://leetcode.cn/problems/maximum-subarray/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/maximum-subarray/</a></p>
<ul>
<li>
<p><strong>dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]</strong>。</p>
</li>
<li>
<p>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</p>
<p>nums[i]，即：从头开始计算当前连续子序列和</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxSubArray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(nums.size());
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> nums[i], nums[i]); <span style="color:#75715e">// 状态转移公式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (dp[i] <span style="color:#f92672">&gt;</span> result) result <span style="color:#f92672">=</span> dp[i]; <span style="color:#75715e">// result 保存dp[i]的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="32判断子序列">32.判断子序列
</h3><p><a class="link" href="https://leetcode.cn/problems/is-subsequence/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/is-subsequence/</a></p>
<ul>
<li><strong>dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]</strong>。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isSubsequence(string s, string t) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(s.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(t.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> t.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (s[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> t[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dp[s.size()][t.size()] <span style="color:#f92672">==</span> s.size()) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n × m)</li>
<li>空间复杂度：O(n × m)</li>
</ul>
<h3 id="33不同的子序列">33.不同的子序列
</h3><p><a class="link" href="https://leetcode.cn/problems/distinct-subsequences/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/distinct-subsequences/</a></p>
<p>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numDistinct(string s, string t) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint64_t</span><span style="color:#f92672">&gt;&gt;</span> dp(s.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint64_t</span><span style="color:#f92672">&gt;</span>(t.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> t.size(); j<span style="color:#f92672">++</span>) dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> t.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (s[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> t[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[s.size()][t.size()];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * m)</li>
<li>空间复杂度: O(n * m)</li>
</ul>
<h3 id="34两个字符串的删除操作">34.两个字符串的删除操作
</h3><p><a class="link" href="https://leetcode.cn/problems/delete-operation-for-two-strings/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p>
<ul>
<li>
<p>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p>
</li>
<li>
<p>当word1[i - 1] 与 word2[j - 1]相同的时候</p>
</li>
<li>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候</p>
</li>
</ul>
<p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] +2</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minDistance(string word1, string word2) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(word1.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(word2.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> word1.size(); i<span style="color:#f92672">++</span>) dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> word2.size(); j<span style="color:#f92672">++</span>) dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> word1.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> word2.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (word1[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> word2[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> min(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[word1.size()][word2.size()];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * m)</li>
<li>空间复杂度: O(n * m)</li>
</ul>
<h3 id="35编辑距离">35.编辑距离
</h3><p><a class="link" href="https://leetcode.cn/problems/edit-distance/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/edit-distance/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minDistance(string word1, string word2) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(word1.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(word2.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> word1.size(); i<span style="color:#f92672">++</span>) dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> word2.size(); j<span style="color:#f92672">++</span>) dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> word1.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> word2.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (word1[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> word2[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> min({dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j], dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]}) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[word1.size()][word2.size()];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n * m)</li>
<li>空间复杂度: O(n * m)</li>
</ul>
<h3 id="36回文子串">36.回文子串
</h3><p><a class="link" href="https://leetcode.cn/problems/palindromic-substrings/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/palindromic-substrings/description/</a></p>
<ul>
<li>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</li>
</ul>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> countSubstrings(string s) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span> dp(s.size(), vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(s.size(), false));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {  <span style="color:#75715e">// 注意遍历顺序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> s.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> s[j]) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">-</span> i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) { <span style="color:#75715e">// 情况一 和 情况二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        result<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                        dp[i][j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) { <span style="color:#75715e">// 情况三
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        result<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                        dp[i][j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<h3 id="37最长回文子序列">37.最长回文子序列
</h3><p><a class="link" href="https://leetcode.cn/problems/longest-palindromic-subsequence/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<p><strong>dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]</strong>。</p>
<p>如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;</p>
<p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p>
<p>加入s[j]的回文子序列长度为dp[i + 1][j]。</p>
<p>加入s[i]的回文子序列长度为dp[i][j - 1]。</p>
<p>那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> longestPalindromeSubseq(string s) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(s.size(), vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(s.size(), <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) dp[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> s.size(); j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> s[j]) {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j], dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">0</span>][s.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)</li>
</ul>
<h3 id="十单调栈">十、单调栈
</h3><h4 id="1每日温度">1.每日温度
</h4><p><a class="link" href="https://leetcode.cn/problems/daily-temperatures/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/daily-temperatures/description/</a></p>
<p><strong>递增单调栈</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 版本一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dailyTemperatures(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> T) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 递增栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> st;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result(T.size(), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        st.push(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> T.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (T[i] <span style="color:#f92672">&lt;</span> T[st.top()]) {                       <span style="color:#75715e">// 情况一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(i);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (T[i] <span style="color:#f92672">==</span> T[st.top()]) {               <span style="color:#75715e">// 情况二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(i);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty() <span style="color:#f92672">&amp;&amp;</span> T[i] <span style="color:#f92672">&gt;</span> T[st.top()]) { <span style="color:#75715e">// 情况三
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    result[st.top()] <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> st.top();
</span></span><span style="display:flex;"><span>                    st.pop();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                st.push(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="2接雨水">2.接雨水
</h3><p><a class="link" href="https://leetcode.cn/problems/trapping-rain-water/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/trapping-rain-water/description/</a></p>
<p><strong>双指针</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> trap(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> height) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (height.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> maxLeft(height.size(), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> maxRight(height.size(), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> maxRight.size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 记录每个柱子左边柱子最大高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        maxLeft[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> height[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            maxLeft[i] <span style="color:#f92672">=</span> max(height[i], maxLeft[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 记录每个柱子右边柱子最大高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        maxRight[size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> height[size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            maxRight[i] <span style="color:#f92672">=</span> max(height[i], maxRight[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 求和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> min(maxLeft[i], maxRight[i]) <span style="color:#f92672">-</span> height[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) sum <span style="color:#f92672">+=</span> count;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><strong>单调栈</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> trap(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> height) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (height.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 可以不加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> st; <span style="color:#75715e">// 存着下标，计算的时候用下标对应的柱子高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        st.push(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> height.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (height[i] <span style="color:#f92672">&lt;</span> height[st.top()]) {     <span style="color:#75715e">// 情况一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(i);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">if</span> (height[i] <span style="color:#f92672">==</span> height[st.top()]) {  <span style="color:#75715e">// 情况二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.pop(); <span style="color:#75715e">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                st.push(i);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {                                <span style="color:#75715e">// 情况三
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty() <span style="color:#f92672">&amp;&amp;</span> height[i] <span style="color:#f92672">&gt;</span> height[st.top()]) { <span style="color:#75715e">// 注意这里是while
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>                    st.pop();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> min(height[st.top()], height[i]) <span style="color:#f92672">-</span> height[mid];
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> st.top() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 注意减一，只求中间宽度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        sum <span style="color:#f92672">+=</span> h <span style="color:#f92672">*</span> w;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                st.push(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="十一图论">十一、图论
</h2><h3 id="1深度优先搜索dfs理论基础">1.深度优先搜索dfs理论基础
</h3><p>dfs的代码框架：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#960050;background-color:#1e0010">参数</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">终止条件</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">存放结果</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#960050;background-color:#1e0010">选择：本节点所连接的其他节点</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">处理节点</span>;
</span></span><span style="display:flex;"><span>        dfs(<span style="color:#960050;background-color:#1e0010">图，选择的节点</span>); <span style="color:#75715e">// 递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#960050;background-color:#1e0010">回溯，撤销处理结果</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2所有可能的路径">2.所有可能的路径
</h3><p><a class="link" href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/all-paths-from-source-to-target/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> result; <span style="color:#75715e">// 收集符合条件的路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> path; <span style="color:#75715e">// 0节点到终点的路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// x：目前遍历的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// graph：存当前的图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span> (vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> graph, <span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> graph.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) { <span style="color:#75715e">// 找到符合条件的一条路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            result.push_back(path);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> graph[x].size(); i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 遍历节点n链接的所有节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            path.push_back(graph[x][i]); <span style="color:#75715e">// 遍历到的节点加入到路径中来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dfs(graph, graph[x][i]); <span style="color:#75715e">// 进入下一层递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            path.pop_back(); <span style="color:#75715e">// 回溯，撤销本节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> allPathsSourceTarget(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> graph) {
</span></span><span style="display:flex;"><span>        path.push_back(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 无论什么路径已经是从0节点出发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        dfs(graph, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 开始遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="3广度优先搜索bfs理论基础">3.广度优先搜索bfs理论基础
</h3><p>广搜的搜索方式就适合于解决两个点之间的最短路径问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dir[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}; <span style="color:#75715e">// 表示四个方向
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// grid 是地图，也就是一个二维数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// visited标记访问过的节点，不要重复访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// x,y 表示开始搜索节点的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;&amp;</span> visited, <span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> que; <span style="color:#75715e">// 定义队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    que.push({x, y}); <span style="color:#75715e">// 起始节点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    visited[x][y] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 只要加入队列，立刻标记为访问过的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>que.empty()) { <span style="color:#75715e">// 开始遍历队列里的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> ,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> cur <span style="color:#f92672">=</span> que.front(); que.pop(); <span style="color:#75715e">// 从队列取元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> curx <span style="color:#f92672">=</span> cur.first;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cury <span style="color:#f92672">=</span> cur.second; <span style="color:#75715e">// 当前节点坐标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// 开始想当前节点的四个方向左右上下去遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> nextx <span style="color:#f92672">=</span> curx <span style="color:#f92672">+</span> dir[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> nexty <span style="color:#f92672">=</span> cury <span style="color:#f92672">+</span> dir[i][<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 获取周边四个方向的坐标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (nextx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nextx <span style="color:#f92672">&gt;=</span> grid.size() <span style="color:#f92672">||</span> nexty <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nexty <span style="color:#f92672">&gt;=</span> grid[<span style="color:#ae81ff">0</span>].size()) <span style="color:#66d9ef">continue</span>;  <span style="color:#75715e">// 坐标越界了，直接跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[nextx][nexty]) { <span style="color:#75715e">// 如果节点没被访问过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                que.push({nextx, nexty});  <span style="color:#75715e">// 队列添加该节点为下一轮要遍历的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                visited[nextx][nexty] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 只要加入队列立刻标记，避免重复访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4岛屿数量dfs">4.岛屿数量dfs
</h3><p><a class="link" href="https://leetcode.cn/problems/number-of-islands/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/number-of-islands/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dir[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}; <span style="color:#75715e">// 四个方向
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;&amp;</span> visited, <span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (visited[x][y] <span style="color:#f92672">||</span> grid[x][y] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// 终止条件：访问过的节点 或者 遇到海水
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        visited[x][y] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 标记访问过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> nextx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dir[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> nexty <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dir[i][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nextx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nextx <span style="color:#f92672">&gt;=</span> grid.size() <span style="color:#f92672">||</span> nexty <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nexty <span style="color:#f92672">&gt;=</span> grid[<span style="color:#ae81ff">0</span>].size()) <span style="color:#66d9ef">continue</span>;  <span style="color:#75715e">// 越界了，直接跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            dfs(grid, visited, nextx, nexty);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numIslands(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> grid.size(), m <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span> visited <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span>(n, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(m, false));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[i][j] <span style="color:#f92672">&amp;&amp;</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                    result<span style="color:#f92672">++</span>; <span style="color:#75715e">// 遇到没访问过的陆地，+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    dfs(grid, visited, i, j); <span style="color:#75715e">// 将与其链接的陆地都标记上 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="5岛屿数量bfs">5.岛屿数量bfs
</h3><p><a class="link" href="https://leetcode.cn/problems/number-of-islands/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/number-of-islands/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dir[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}; <span style="color:#75715e">// 四个方向
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;&amp;</span> visited, <span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> que;
</span></span><span style="display:flex;"><span>    que.push({x, y});
</span></span><span style="display:flex;"><span>    visited[x][y] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 只要加入队列，立刻标记
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>que.empty()) {
</span></span><span style="display:flex;"><span>        pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> ,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> cur <span style="color:#f92672">=</span> que.front(); que.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> curx <span style="color:#f92672">=</span> cur.first;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cury <span style="color:#f92672">=</span> cur.second;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> nextx <span style="color:#f92672">=</span> curx <span style="color:#f92672">+</span> dir[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> nexty <span style="color:#f92672">=</span> cury <span style="color:#f92672">+</span> dir[i][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nextx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nextx <span style="color:#f92672">&gt;=</span> grid.size() <span style="color:#f92672">||</span> nexty <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nexty <span style="color:#f92672">&gt;=</span> grid[<span style="color:#ae81ff">0</span>].size()) <span style="color:#66d9ef">continue</span>;  <span style="color:#75715e">// 越界了，直接跳过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[nextx][nexty] <span style="color:#f92672">&amp;&amp;</span> grid[nextx][nexty] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                que.push({nextx, nexty});
</span></span><span style="display:flex;"><span>                visited[nextx][nexty] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 只要加入队列立刻标记
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numIslands(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> grid.size(), m <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span> visited <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span>(n, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(m, false));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[i][j] <span style="color:#f92672">&amp;&amp;</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                    result<span style="color:#f92672">++</span>; <span style="color:#75715e">// 遇到没访问过的陆地，+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    bfs(grid, visited, i, j); <span style="color:#75715e">// 将与其链接的陆地都标记上 true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="十一线段树">十一、线段树
</h2><h1 id="hot-100">Hot 100
</h1><h2 id="一哈希">一、哈希
</h2><h3 id="1字母异位词分组">1.字母异位词分组
</h3><p><a class="link" href="https://leetcode.cn/problems/group-anagrams/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/group-anagrams/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;</span> groupAnagrams(vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> strs) {
</span></span><span style="display:flex;"><span>      unordered_map<span style="color:#f92672">&lt;</span>string,vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;</span> mp;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> (string<span style="color:#f92672">&amp;</span> str:strs)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        string tmp <span style="color:#f92672">=</span> str;
</span></span><span style="display:flex;"><span>        sort(tmp.begin(),tmp.end());
</span></span><span style="display:flex;"><span>        mp[tmp].push_back(str);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&gt;</span> result;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> mp.begin();it<span style="color:#f92672">!=</span>mp.end();<span style="color:#f92672">++</span>it)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        result.push_back(it<span style="color:#f92672">-&gt;</span>second);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="2最长连续序列">2.最长连续序列
</h3><p><a class="link" href="https://leetcode.cn/problems/longest-consecutive-sequence"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/longest-consecutive-sequence</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> longestConsecutive(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> nums.size();
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> uset;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span>nums.size();i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            uset.insert(nums[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> item : uset )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>uset.count(item <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> item;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (uset.find(<span style="color:#f92672">++</span>a) <span style="color:#f92672">!=</span> uset.end()) 
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    length<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                result <span style="color:#f92672">=</span> result <span style="color:#f92672">&gt;</span> length <span style="color:#f92672">?</span> result : length; 
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="二双指针">二、双指针
</h2><h3 id="1移动0">1.移动0
</h3><p><a class="link" href="https://leetcode.cn/problems/move-zeroes/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/move-zeroes/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> moveZeroes(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> right<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;right<span style="color:#f92672">&lt;</span>nums.size();right<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nums[right] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> nums[left] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) swap(nums[right],nums[left<span style="color:#f92672">++</span>]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nums[left] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="2盛最多水的容器">2.盛最多水的容器
</h3><p><a class="link" href="https://leetcode.cn/problems/container-with-most-water/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/container-with-most-water/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxArea(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> height) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, curArea <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> height.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;</span>j ;)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        curArea <span style="color:#f92672">=</span> min(height[j],height[i]) <span style="color:#f92672">*</span> (j <span style="color:#f92672">-</span> i);
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> max(result,curArea);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (height[i] <span style="color:#f92672">&lt;=</span> height[j]) i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> j<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="3接雨水">3.接雨水
</h3><p><a class="link" href="https://leetcode.cn/problems/trapping-rain-water/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/trapping-rain-water/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> trap(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> height) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> height.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> maxLeft(size,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> maxRight(size,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        maxLeft[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> height[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            maxLeft[i] <span style="color:#f92672">=</span> max(height[i],maxLeft[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        maxRight[size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> height[size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> size<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            maxRight[i] <span style="color:#f92672">=</span> max(height[i],maxRight[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">+=</span>  min(maxLeft[i],maxRight[i]) <span style="color:#f92672">-</span> height[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="三滑动窗">三、滑动窗
</h2><h3 id="1无重复字符的最长子串">1.无重复字符的最长子串
</h3><p><a class="link" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lengthOfLongestSubstring(string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> s.size();
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> uset;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rightIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>s.size();i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) uset.erase(s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);   <span style="color:#75715e">//左指针增加，移除上一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (rightIndex <span style="color:#f92672">&lt;</span> s.size() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>uset.count(s[rightIndex]))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                uset.insert(s[rightIndex]);
</span></span><span style="display:flex;"><span>                rightIndex<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">=</span> max(result,rightIndex<span style="color:#f92672">-</span>i);  <span style="color:#75715e">//循环结束前右指针多加了1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="2找到字符串中所有字母异位词">2.找到字符串中所有字母异位词
</h3><p><a class="link" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> findAnagrams(string s, string p) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sLen <span style="color:#f92672">=</span> s.size(), pLen <span style="color:#f92672">=</span> p.size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sLen <span style="color:#f92672">&lt;</span> pLen) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sCount(<span style="color:#ae81ff">26</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pCount(<span style="color:#ae81ff">26</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pLen; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            sCount[s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            pCount[p[i]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sCount <span style="color:#f92672">==</span> pCount) result.push_back(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">//vector的比较方法，为一一比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> s:result) cout<span style="color:#f92672">&lt;&lt;</span>s<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> sLen <span style="color:#f92672">-</span> pLen; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            sCount[s[i]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            sCount[s[i <span style="color:#f92672">+</span> pLen]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (sCount <span style="color:#f92672">==</span> pCount) result.push_back(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="3和为-k-的子数组">3.和为 K 的子数组
</h3><p><a class="link" href="https://leetcode.cn/problems/subarray-sum-equals-k/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
<p><strong>前缀和 + 哈希表优化</strong></p>
<p>pre[i]:[0，i]的和；</p>
<p>[i,j]区间的和为k：pre[j]-pre[i-1] == k</p>
<p>转化为：pre[i-1] = pre[j]-k</p>
<p>建哈希map查找</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> subarraySum(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mp;  <span style="color:#75715e">//key:[0-i]的和，val:次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        mp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, pre <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> x:nums)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            pre <span style="color:#f92672">+=</span> x;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (mp.find(pre <span style="color:#f92672">-</span> k) <span style="color:#f92672">!=</span> mp.end()) count <span style="color:#f92672">+=</span> mp[pre <span style="color:#f92672">-</span> k];
</span></span><span style="display:flex;"><span>            mp[pre]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="四普通数组">四、普通数组
</h2><h3 id="1轮转数组">1.轮转数组
</h3><p><a class="link" href="https://leetcode.cn/problems/rotate-array/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/rotate-array/</a></p>
<p>方法一：拷贝数组 方法二：翻转数组</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> rotate(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">%=</span> nums.size();
</span></span><span style="display:flex;"><span>        reverse(nums.begin(),nums.end());
</span></span><span style="display:flex;"><span>        reverse(nums.begin(),nums.begin() <span style="color:#f92672">+</span> k);
</span></span><span style="display:flex;"><span>        reverse(nums.begin() <span style="color:#f92672">+</span> k,nums.end());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="2除自身以外数组的乘积">2.除自身以外数组的乘积
</h3><p><a class="link" href="https://leetcode.cn/problems/product-of-array-except-self"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/product-of-array-except-self</a></p>
<p><strong>左右乘积列表</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> productExceptSelf(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> L(nums.size(),<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> R(nums.size(),<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result(nums.size(),<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        L[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;</span>nums.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            L[i] <span style="color:#f92672">=</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> L[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        R[size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            R[i] <span style="color:#f92672">=</span> nums[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> R[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>nums.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            result[i] <span style="color:#f92672">=</span> L[i] <span style="color:#f92672">*</span> R[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="3缺失的第一个正数">3.缺失的第一个正数
</h3><p><a class="link" href="https://leetcode.cn/problems/first-missing-positive/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/first-missing-positive/</a></p>
<p><strong>原地哈希</strong></p>
<p>数值为1的放在0，数值为2的放在1。即数值为i+1的放在索引为i的位置，进行交换。</p>
<p>再遍历一遍位置错误的就是他</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> firstMissingPositive(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (nums[i] <span style="color:#f92672">!=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nums[i] <span style="color:#f92672">&gt;</span> nums.size() <span style="color:#f92672">||</span> nums[i] <span style="color:#f92672">==</span> nums[nums[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 将nums[i] 放置到对应位置上[1,2,3...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> nums[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                nums[i] <span style="color:#f92672">=</span> nums[idx];
</span></span><span style="display:flex;"><span>                nums[idx] <span style="color:#f92672">=</span> idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">!=</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (nums.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="面试热题">面试热题
</h1><h3 id="2二叉树的直径">2.二叉树的直径
</h3><p><a class="link" href="https://leetcode.cn/problems/diameter-of-binary-tree/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/diameter-of-binary-tree/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">depth</span>(TreeNode<span style="color:#f92672">*</span> root)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> depth(root<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> R <span style="color:#f92672">=</span> depth(root<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">=</span> max(ans, L<span style="color:#f92672">+</span>R);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> max(L,R)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">diameterOfBinaryTree</span>(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        ans<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        depth(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="3合并两个有序数组">3.合并两个有序数组
</h3><p><a class="link" href="https://leetcode.cn/problems/merge-sorted-array/description/"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/merge-sorted-array/description/</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> merge(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums1, <span style="color:#66d9ef">int</span> m, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums2, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> nums1.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        m<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        n<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>)     <span style="color:#75715e">//还有需要合并的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (m <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> nums1[m] <span style="color:#f92672">&gt;</span> nums2[n]) {
</span></span><span style="display:flex;"><span>                nums1[i<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> nums1[m<span style="color:#f92672">--</span>];
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            nums1[i<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> nums2[n<span style="color:#f92672">--</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>
</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="pikapika-zrf/pikapika-zrf.github.io"
        issue-term="pathname"
        
        label="comment"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 raff
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
